# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class SolarHubActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.SolarHub]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await SolarHub.prisma().query_raw(
            'SELECT * FROM SolarHub WHERE hub_id = $1',
            13242331080,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.SolarHub
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await SolarHub.prisma().query_first(
            'SELECT * FROM SolarHub WHERE what_three_word_location = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.SolarHubCreateInput,
        include: Optional[types.SolarHubInclude] = None
    ) -> _PrismaModelT:
        """Create a new SolarHub record.

        Parameters
        ----------
        data
            SolarHub record data
        include
            Specifies which relations should be loaded on the returned SolarHub model

        Returns
        -------
        prisma.models.SolarHub
            The created SolarHub record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a SolarHub record from just the required fields
        solarhub = await SolarHub.prisma().create(
            data={
                # data to create a SolarHub record
                'hub_id': 7953889008,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.SolarHubCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple SolarHub records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of SolarHub record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await SolarHub.prisma().create_many(
            data=[
                {
                    # data to create a SolarHub record
                    'hub_id': 13774833372,
                },
                {
                    # data to create a SolarHub record
                    'hub_id': 24420185688,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.SolarHubWhereUniqueInput,
        include: Optional[types.SolarHubInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single SolarHub record.

        Parameters
        ----------
        where
            SolarHub filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned SolarHub model

        Returns
        -------
        prisma.models.SolarHub
            The deleted SolarHub record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        solarhub = await SolarHub.prisma().delete(
            where={
                'hub_id': 4425610788,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.SolarHubWhereUniqueInput,
        include: Optional[types.SolarHubInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique SolarHub record.

        Parameters
        ----------
        where
            SolarHub filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned SolarHub model

        Returns
        -------
        prisma.models.SolarHub
            The found SolarHub record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        solarhub = await SolarHub.prisma().find_unique(
            where={
                'hub_id': 18096359424,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.SolarHubWhereUniqueInput,
        include: Optional[types.SolarHubInclude] = None
    ) -> _PrismaModelT:
        """Find a unique SolarHub record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            SolarHub filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned SolarHub model

        Returns
        -------
        prisma.models.SolarHub
            The found SolarHub record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        solarhub = await SolarHub.prisma().find_unique_or_raise(
            where={
                'hub_id': 5835074220,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SolarHubWhereInput] = None,
        cursor: Optional[types.SolarHubWhereUniqueInput] = None,
        include: Optional[types.SolarHubInclude] = None,
        order: Optional[Union[types.SolarHubOrderByInput, List[types.SolarHubOrderByInput]]] = None,
        distinct: Optional[List[types.SolarHubScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple SolarHub records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of SolarHub records returned
        skip
            Ignore the first N results
        where
            SolarHub filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SolarHub model
        order
            Order the returned SolarHub records by any field
        distinct
            Filter SolarHub records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.SolarHub]
            The list of all SolarHub records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 SolarHub records
        solarhubs = await SolarHub.prisma().find_many(take=10)

        # find the first 5 SolarHub records ordered by the solar_capacity_kw field
        solarhubs = await SolarHub.prisma().find_many(
            take=5,
            order={
                'solar_capacity_kw': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SolarHubWhereInput] = None,
        cursor: Optional[types.SolarHubWhereUniqueInput] = None,
        include: Optional[types.SolarHubInclude] = None,
        order: Optional[Union[types.SolarHubOrderByInput, List[types.SolarHubOrderByInput]]] = None,
        distinct: Optional[List[types.SolarHubScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single SolarHub record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            SolarHub filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SolarHub model
        order
            Order the returned SolarHub records by any field
        distinct
            Filter SolarHub records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.SolarHub
            The first SolarHub record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second SolarHub record ordered by the country field
        solarhub = await SolarHub.prisma().find_first(
            skip=1,
            order={
                'country': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SolarHubWhereInput] = None,
        cursor: Optional[types.SolarHubWhereUniqueInput] = None,
        include: Optional[types.SolarHubInclude] = None,
        order: Optional[Union[types.SolarHubOrderByInput, List[types.SolarHubOrderByInput]]] = None,
        distinct: Optional[List[types.SolarHubScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single SolarHub record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            SolarHub filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SolarHub model
        order
            Order the returned SolarHub records by any field
        distinct
            Filter SolarHub records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.SolarHub
            The first SolarHub record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second SolarHub record ordered by the latitude field
        solarhub = await SolarHub.prisma().find_first_or_raise(
            skip=1,
            order={
                'latitude': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.SolarHubUpdateInput,
        where: types.SolarHubWhereUniqueInput,
        include: Optional[types.SolarHubInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single SolarHub record.

        Parameters
        ----------
        data
            SolarHub record data specifying what to update
        where
            SolarHub filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned SolarHub model

        Returns
        -------
        prisma.models.SolarHub
            The updated SolarHub record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        solarhub = await SolarHub.prisma().update(
            where={
                'hub_id': 12750214632,
            },
            data={
                # data to update the SolarHub record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.SolarHubWhereUniqueInput,
        data: types.SolarHubUpsertInput,
        include: Optional[types.SolarHubInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            SolarHub filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned SolarHub model

        Returns
        -------
        prisma.models.SolarHub
            The created or updated SolarHub record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        solarhub = await SolarHub.prisma().upsert(
            where={
                'hub_id': 3214018164,
            },
            data={
                'create': {
                    'hub_id': 3214018164,
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.SolarHubUpdateManyMutationInput,
        where: types.SolarHubWhereInput,
    ) -> int:
        """Update multiple SolarHub records

        Parameters
        ----------
        data
            SolarHub data to update the selected SolarHub records to
        where
            Filter to select the SolarHub records to update

        Returns
        -------
        int
            The total number of SolarHub records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all SolarHub records
        total = await SolarHub.prisma().update_many(
            data={
                'longitude': 180171308.83676
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SolarHubWhereInput] = None,
        cursor: Optional[types.SolarHubWhereUniqueInput] = None,
    ) -> int:
        """Count the number of SolarHub records present in the database

        Parameters
        ----------
        select
            Select the SolarHub fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            SolarHub filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SolarHubCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await SolarHub.prisma().count()

        # results: prisma.types.SolarHubCountAggregateOutput
        results = await SolarHub.prisma().count(
            select={
                '_all': True,
                'hub_id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.SolarHubCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SolarHubWhereInput] = None,
        cursor: Optional[types.SolarHubWhereUniqueInput] = None,
    ) -> types.SolarHubCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.SolarHubCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SolarHubWhereInput] = None,
        cursor: Optional[types.SolarHubWhereUniqueInput] = None,
    ) -> Union[int, types.SolarHubCountAggregateOutput]:
        """Count the number of SolarHub records present in the database

        Parameters
        ----------
        select
            Select the SolarHub fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            SolarHub filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SolarHubCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await SolarHub.prisma().count()

        # results: prisma.types.SolarHubCountAggregateOutput
        results = await SolarHub.prisma().count(
            select={
                '_all': True,
                'what_three_word_location': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.SolarHubCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.SolarHubWhereInput] = None
    ) -> int:
        """Delete multiple SolarHub records.

        Parameters
        ----------
        where
            Optional SolarHub filter to find the records to be deleted

        Returns
        -------
        int
            The total number of SolarHub records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all SolarHub records
        total = await SolarHub.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.SolarHubScalarFieldKeys'],
        *,
        where: Optional['types.SolarHubWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.SolarHubAvgAggregateInput'] = None,
        sum: Optional['types.SolarHubSumAggregateInput'] = None,
        min: Optional['types.SolarHubMinAggregateInput'] = None,
        max: Optional['types.SolarHubMaxAggregateInput'] = None,
        having: Optional['types.SolarHubScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.SolarHubCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.SolarHubScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.SolarHubScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.SolarHubGroupByOutput']:
        """Group SolarHub records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar SolarHub fields to group records by
        where
            SolarHub filter to select records
        take
            Limit the maximum number of SolarHub records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.SolarHubGroupByOutput]
            A list of dictionaries representing the SolarHub record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group SolarHub records by solar_capacity_kw values
        # and count how many records are in each group
        results = await SolarHub.prisma().group_by(
            ['solar_capacity_kw'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.User]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await User.prisma().query_raw(
            'SELECT * FROM User WHERE user_id = $1',
            7144054392,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.User
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().query_first(
            'SELECT * FROM User WHERE Name = $1',
            'hjaecfifb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserCreateInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Create a new User record.

        Parameters
        ----------
        data
            User record data
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created User record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a User record from just the required fields
        user = await User.prisma().create(
            data={
                # data to create a User record
                'user_id': 25342983456,
                'Name': 'bbejhfidcb',
                'hub_id': 19731472392,
                'user_access_level': 'bdiicjafbj',
                'username': 'bgehebiafc',
                'password_hash': 'bghffegacj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple User records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of User record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await User.prisma().create_many(
            data=[
                {
                    # data to create a User record
                    'user_id': 21207296664,
                    'Name': 'dcgchcbbf',
                    'hub_id': 16118412864,
                    'user_access_level': 'ghfhiafcb',
                    'username': 'heejgedji',
                    'password_hash': 'bjgjgibgbf',
                },
                {
                    # data to create a User record
                    'user_id': 13394111568,
                    'Name': 'igbehcbab',
                    'hub_id': 15636044472,
                    'user_access_level': 'bgiggdidbf',
                    'username': 'caaaedabfc',
                    'password_hash': 'bigibebcib',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single User record.

        Parameters
        ----------
        where
            User filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The deleted User record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().delete(
            where={
                'user_id': 22330171464,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique User record.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique(
            where={
                'user_id': 17382256980,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Find a unique User record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique_or_raise(
            where={
                'user_id': 19543808880,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple User records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N results
        where
            User filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.User]
            The list of all User records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 User records
        users = await User.prisma().find_many(take=10)

        # find the first 5 User records ordered by the users_identification_document_number field
        users = await User.prisma().find_many(
            take=5,
            order={
                'users_identification_document_number': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single User record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the mobile_number field
        user = await User.prisma().find_first(
            skip=1,
            order={
                'mobile_number': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single User record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the address field
        user = await User.prisma().find_first_or_raise(
            skip=1,
            order={
                'address': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserUpdateInput,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single User record.

        Parameters
        ----------
        data
            User record data specifying what to update
        where
            User filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The updated User record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().update(
            where={
                'user_id': 14995280220,
            },
            data={
                # data to update the User record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserWhereUniqueInput,
        data: types.UserUpsertInput,
        include: Optional[types.UserInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            User filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created or updated User record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().upsert(
            where={
                'user_id': 10030837464,
            },
            data={
                'create': {
                    'user_id': 10030837464,
                    'Name': 'igbehcbab',
                    'hub_id': 15636044472,
                    'user_access_level': 'bgiggdidbf',
                    'username': 'caaaedabfc',
                    'password_hash': 'bigibebcib',
                },
                'update': {
                    'Name': 'igbehcbab',
                    'hub_id': 15636044472,
                    'user_access_level': 'bgiggdidbf',
                    'username': 'caaaedabfc',
                    'password_hash': 'bigibebcib',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserUpdateManyMutationInput,
        where: types.UserWhereInput,
    ) -> int:
        """Update multiple User records

        Parameters
        ----------
        data
            User data to update the selected User records to
        where
            Filter to select the User records to update

        Returns
        -------
        int
            The total number of User records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all User records
        total = await User.prisma().update_many(
            data={
                'hub_id': 9164637348
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> int:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'user_access_level': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> types.UserCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> Union[int, types.UserCountAggregateOutput]:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'username': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserWhereInput] = None
    ) -> int:
        """Delete multiple User records.

        Parameters
        ----------
        where
            Optional User filter to find the records to be deleted

        Returns
        -------
        int
            The total number of User records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all User records
        total = await User.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserScalarFieldKeys'],
        *,
        where: Optional['types.UserWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserAvgAggregateInput'] = None,
        sum: Optional['types.UserSumAggregateInput'] = None,
        min: Optional['types.UserMinAggregateInput'] = None,
        max: Optional['types.UserMaxAggregateInput'] = None,
        having: Optional['types.UserScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserGroupByOutput']:
        """Group User records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar User fields to group records by
        where
            User filter to select records
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserGroupByOutput]
            A list of dictionaries representing the User record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group User records by password_hash values
        # and count how many records are in each group
        results = await User.prisma().group_by(
            ['password_hash'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class NoteActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Note]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Note.prisma().query_raw(
            'SELECT * FROM Note WHERE id = $1',
            5159941248,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Note
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Note.prisma().query_first(
            'SELECT * FROM Note WHERE content = $1',
            'bhhfibbigf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.NoteCreateInput,
        include: Optional[types.NoteInclude] = None
    ) -> _PrismaModelT:
        """Create a new Note record.

        Parameters
        ----------
        data
            Note record data
        include
            Specifies which relations should be loaded on the returned Note model

        Returns
        -------
        prisma.models.Note
            The created Note record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Note record from just the required fields
        note = await Note.prisma().create(
            data={
                # data to create a Note record
                'id': 10717746792,
                'content': 'jjfeafhfj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.NoteCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Note records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Note record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Note.prisma().create_many(
            data=[
                {
                    # data to create a Note record
                    'id': 25232838288,
                    'content': 'chbfcacbd',
                },
                {
                    # data to create a Note record
                    'id': 5479606008,
                    'content': 'caficfigfb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.NoteWhereUniqueInput,
        include: Optional[types.NoteInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Note record.

        Parameters
        ----------
        where
            Note filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Note model

        Returns
        -------
        prisma.models.Note
            The deleted Note record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        note = await Note.prisma().delete(
            where={
                'id': 19004275104,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.NoteWhereUniqueInput,
        include: Optional[types.NoteInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Note record.

        Parameters
        ----------
        where
            Note filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Note model

        Returns
        -------
        prisma.models.Note
            The found Note record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        note = await Note.prisma().find_unique(
            where={
                'id': 10541304780,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.NoteWhereUniqueInput,
        include: Optional[types.NoteInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Note record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Note filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Note model

        Returns
        -------
        prisma.models.Note
            The found Note record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        note = await Note.prisma().find_unique_or_raise(
            where={
                'id': 20103360648,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NoteWhereInput] = None,
        cursor: Optional[types.NoteWhereUniqueInput] = None,
        include: Optional[types.NoteInclude] = None,
        order: Optional[Union[types.NoteOrderByInput, List[types.NoteOrderByInput]]] = None,
        distinct: Optional[List[types.NoteScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Note records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Note records returned
        skip
            Ignore the first N results
        where
            Note filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Note model
        order
            Order the returned Note records by any field
        distinct
            Filter Note records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Note]
            The list of all Note records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Note records
        notes = await Note.prisma().find_many(take=10)

        # find the first 5 Note records ordered by the created_at field
        notes = await Note.prisma().find_many(
            take=5,
            order={
                'created_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.NoteWhereInput] = None,
        cursor: Optional[types.NoteWhereUniqueInput] = None,
        include: Optional[types.NoteInclude] = None,
        order: Optional[Union[types.NoteOrderByInput, List[types.NoteOrderByInput]]] = None,
        distinct: Optional[List[types.NoteScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Note record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Note filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Note model
        order
            Order the returned Note records by any field
        distinct
            Filter Note records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Note
            The first Note record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Note record ordered by the id field
        note = await Note.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.NoteWhereInput] = None,
        cursor: Optional[types.NoteWhereUniqueInput] = None,
        include: Optional[types.NoteInclude] = None,
        order: Optional[Union[types.NoteOrderByInput, List[types.NoteOrderByInput]]] = None,
        distinct: Optional[List[types.NoteScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Note record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Note filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Note model
        order
            Order the returned Note records by any field
        distinct
            Filter Note records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Note
            The first Note record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Note record ordered by the content field
        note = await Note.prisma().find_first_or_raise(
            skip=1,
            order={
                'content': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.NoteUpdateInput,
        where: types.NoteWhereUniqueInput,
        include: Optional[types.NoteInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Note record.

        Parameters
        ----------
        data
            Note record data specifying what to update
        where
            Note filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Note model

        Returns
        -------
        prisma.models.Note
            The updated Note record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        note = await Note.prisma().update(
            where={
                'id': 19530914964,
            },
            data={
                # data to update the Note record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.NoteWhereUniqueInput,
        data: types.NoteUpsertInput,
        include: Optional[types.NoteInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Note filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Note model

        Returns
        -------
        prisma.models.Note
            The created or updated Note record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        note = await Note.prisma().upsert(
            where={
                'id': 24657626544,
            },
            data={
                'create': {
                    'id': 24657626544,
                    'content': 'caficfigfb',
                },
                'update': {
                    'content': 'caficfigfb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.NoteUpdateManyMutationInput,
        where: types.NoteWhereInput,
    ) -> int:
        """Update multiple Note records

        Parameters
        ----------
        data
            Note data to update the selected Note records to
        where
            Filter to select the Note records to update

        Returns
        -------
        int
            The total number of Note records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Note records
        total = await Note.prisma().update_many(
            data={
                'created_at': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NoteWhereInput] = None,
        cursor: Optional[types.NoteWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Note records present in the database

        Parameters
        ----------
        select
            Select the Note fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Note filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.NoteCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Note.prisma().count()

        # results: prisma.types.NoteCountAggregateOutput
        results = await Note.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.NoteCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NoteWhereInput] = None,
        cursor: Optional[types.NoteWhereUniqueInput] = None,
    ) -> types.NoteCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.NoteCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NoteWhereInput] = None,
        cursor: Optional[types.NoteWhereUniqueInput] = None,
    ) -> Union[int, types.NoteCountAggregateOutput]:
        """Count the number of Note records present in the database

        Parameters
        ----------
        select
            Select the Note fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Note filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.NoteCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Note.prisma().count()

        # results: prisma.types.NoteCountAggregateOutput
        results = await Note.prisma().count(
            select={
                '_all': True,
                'content': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.NoteCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.NoteWhereInput] = None
    ) -> int:
        """Delete multiple Note records.

        Parameters
        ----------
        where
            Optional Note filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Note records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Note records
        total = await Note.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.NoteScalarFieldKeys'],
        *,
        where: Optional['types.NoteWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.NoteAvgAggregateInput'] = None,
        sum: Optional['types.NoteSumAggregateInput'] = None,
        min: Optional['types.NoteMinAggregateInput'] = None,
        max: Optional['types.NoteMaxAggregateInput'] = None,
        having: Optional['types.NoteScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.NoteCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.NoteScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.NoteScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.NoteGroupByOutput']:
        """Group Note records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Note fields to group records by
        where
            Note filter to select records
        take
            Limit the maximum number of Note records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.NoteGroupByOutput]
            A list of dictionaries representing the Note record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Note records by created_at values
        # and count how many records are in each group
        results = await Note.prisma().group_by(
            ['created_at'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class BEPPPBattery_NotesActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.BEPPPBattery_Notes]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await BEPPPBattery_Notes.prisma().query_raw(
            'SELECT * FROM BEPPPBattery_Notes WHERE battery_id = $1',
            724029084,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.BEPPPBattery_Notes
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await BEPPPBattery_Notes.prisma().query_first(
            'SELECT * FROM BEPPPBattery_Notes WHERE note_id = $1',
            8213545752,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.BEPPPBattery_NotesCreateInput,
        include: Optional[types.BEPPPBattery_NotesInclude] = None
    ) -> _PrismaModelT:
        """Create a new BEPPPBattery_Notes record.

        Parameters
        ----------
        data
            BEPPPBattery_Notes record data
        include
            Specifies which relations should be loaded on the returned BEPPPBattery_Notes model

        Returns
        -------
        prisma.models.BEPPPBattery_Notes
            The created BEPPPBattery_Notes record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a BEPPPBattery_Notes record from just the required fields
        bepppbattery_notes = await BEPPPBattery_Notes.prisma().create(
            data={
                # data to create a BEPPPBattery_Notes record
                'battery_id': 19506045924,
                'note_id': 6261932736,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.BEPPPBattery_NotesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple BEPPPBattery_Notes records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of BEPPPBattery_Notes record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await BEPPPBattery_Notes.prisma().create_many(
            data=[
                {
                    # data to create a BEPPPBattery_Notes record
                    'battery_id': 15192387180,
                    'note_id': 1119039144,
                },
                {
                    # data to create a BEPPPBattery_Notes record
                    'battery_id': 24636575796,
                    'note_id': 8223998160,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.BEPPPBattery_NotesWhereUniqueInput,
        include: Optional[types.BEPPPBattery_NotesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single BEPPPBattery_Notes record.

        Parameters
        ----------
        where
            BEPPPBattery_Notes filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned BEPPPBattery_Notes model

        Returns
        -------
        prisma.models.BEPPPBattery_Notes
            The deleted BEPPPBattery_Notes record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        bepppbattery_notes = await BEPPPBattery_Notes.prisma().delete(
            where={
                # BEPPPBattery_Notes where unique filter

            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.BEPPPBattery_NotesWhereUniqueInput,
        include: Optional[types.BEPPPBattery_NotesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique BEPPPBattery_Notes record.

        Parameters
        ----------
        where
            BEPPPBattery_Notes filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned BEPPPBattery_Notes model

        Returns
        -------
        prisma.models.BEPPPBattery_Notes
            The found BEPPPBattery_Notes record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        bepppbattery_notes = await BEPPPBattery_Notes.prisma().find_unique(
            where={
                # BEPPPBattery_Notes where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.BEPPPBattery_NotesWhereUniqueInput,
        include: Optional[types.BEPPPBattery_NotesInclude] = None
    ) -> _PrismaModelT:
        """Find a unique BEPPPBattery_Notes record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            BEPPPBattery_Notes filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned BEPPPBattery_Notes model

        Returns
        -------
        prisma.models.BEPPPBattery_Notes
            The found BEPPPBattery_Notes record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        bepppbattery_notes = await BEPPPBattery_Notes.prisma().find_unique_or_raise(
            where={
                # BEPPPBattery_Notes where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BEPPPBattery_NotesWhereInput] = None,
        cursor: Optional[types.BEPPPBattery_NotesWhereUniqueInput] = None,
        include: Optional[types.BEPPPBattery_NotesInclude] = None,
        order: Optional[Union[types.BEPPPBattery_NotesOrderByInput, List[types.BEPPPBattery_NotesOrderByInput]]] = None,
        distinct: Optional[List[types.BEPPPBattery_NotesScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple BEPPPBattery_Notes records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of BEPPPBattery_Notes records returned
        skip
            Ignore the first N results
        where
            BEPPPBattery_Notes filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned BEPPPBattery_Notes model
        order
            Order the returned BEPPPBattery_Notes records by any field
        distinct
            Filter BEPPPBattery_Notes records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.BEPPPBattery_Notes]
            The list of all BEPPPBattery_Notes records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 BEPPPBattery_Notes records
        bepppbattery_notes = await BEPPPBattery_Notes.prisma().find_many(take=10)

        # find the first 5 BEPPPBattery_Notes records ordered by the battery_id field
        bepppbattery_notes = await BEPPPBattery_Notes.prisma().find_many(
            take=5,
            order={
                'battery_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.BEPPPBattery_NotesWhereInput] = None,
        cursor: Optional[types.BEPPPBattery_NotesWhereUniqueInput] = None,
        include: Optional[types.BEPPPBattery_NotesInclude] = None,
        order: Optional[Union[types.BEPPPBattery_NotesOrderByInput, List[types.BEPPPBattery_NotesOrderByInput]]] = None,
        distinct: Optional[List[types.BEPPPBattery_NotesScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single BEPPPBattery_Notes record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            BEPPPBattery_Notes filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned BEPPPBattery_Notes model
        order
            Order the returned BEPPPBattery_Notes records by any field
        distinct
            Filter BEPPPBattery_Notes records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.BEPPPBattery_Notes
            The first BEPPPBattery_Notes record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second BEPPPBattery_Notes record ordered by the note_id field
        bepppbattery_notes = await BEPPPBattery_Notes.prisma().find_first(
            skip=1,
            order={
                'note_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.BEPPPBattery_NotesWhereInput] = None,
        cursor: Optional[types.BEPPPBattery_NotesWhereUniqueInput] = None,
        include: Optional[types.BEPPPBattery_NotesInclude] = None,
        order: Optional[Union[types.BEPPPBattery_NotesOrderByInput, List[types.BEPPPBattery_NotesOrderByInput]]] = None,
        distinct: Optional[List[types.BEPPPBattery_NotesScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single BEPPPBattery_Notes record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            BEPPPBattery_Notes filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned BEPPPBattery_Notes model
        order
            Order the returned BEPPPBattery_Notes records by any field
        distinct
            Filter BEPPPBattery_Notes records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.BEPPPBattery_Notes
            The first BEPPPBattery_Notes record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second BEPPPBattery_Notes record ordered by the battery_id field
        bepppbattery_notes = await BEPPPBattery_Notes.prisma().find_first_or_raise(
            skip=1,
            order={
                'battery_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.BEPPPBattery_NotesUpdateInput,
        where: types.BEPPPBattery_NotesWhereUniqueInput,
        include: Optional[types.BEPPPBattery_NotesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single BEPPPBattery_Notes record.

        Parameters
        ----------
        data
            BEPPPBattery_Notes record data specifying what to update
        where
            BEPPPBattery_Notes filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned BEPPPBattery_Notes model

        Returns
        -------
        prisma.models.BEPPPBattery_Notes
            The updated BEPPPBattery_Notes record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        bepppbattery_notes = await BEPPPBattery_Notes.prisma().update(
            where={
                # BEPPPBattery_Notes where unique filter

            },
            data={
                # data to update the BEPPPBattery_Notes record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.BEPPPBattery_NotesWhereUniqueInput,
        data: types.BEPPPBattery_NotesUpsertInput,
        include: Optional[types.BEPPPBattery_NotesInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            BEPPPBattery_Notes filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned BEPPPBattery_Notes model

        Returns
        -------
        prisma.models.BEPPPBattery_Notes
            The created or updated BEPPPBattery_Notes record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        bepppbattery_notes = await BEPPPBattery_Notes.prisma().upsert(
            where={
                # BEPPPBattery_Notes where unique filter
            },
            data={
                'create': {
                    # BEPPPBattery_Notes data to be set if the record does not exist
                },
                'update': {
                    # BEPPPBattery_Notes data to be set if the record does exist
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.BEPPPBattery_NotesUpdateManyMutationInput,
        where: types.BEPPPBattery_NotesWhereInput,
    ) -> int:
        """Update multiple BEPPPBattery_Notes records

        Parameters
        ----------
        data
            BEPPPBattery_Notes data to update the selected BEPPPBattery_Notes records to
        where
            Filter to select the BEPPPBattery_Notes records to update

        Returns
        -------
        int
            The total number of BEPPPBattery_Notes records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all BEPPPBattery_Notes records
        total = await BEPPPBattery_Notes.prisma().update_many(
            data={
                'note_id': 1529690940
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BEPPPBattery_NotesWhereInput] = None,
        cursor: Optional[types.BEPPPBattery_NotesWhereUniqueInput] = None,
    ) -> int:
        """Count the number of BEPPPBattery_Notes records present in the database

        Parameters
        ----------
        select
            Select the BEPPPBattery_Notes fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            BEPPPBattery_Notes filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.BEPPPBattery_NotesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await BEPPPBattery_Notes.prisma().count()

        # results: prisma.types.BEPPPBattery_NotesCountAggregateOutput
        results = await BEPPPBattery_Notes.prisma().count(
            select={
                '_all': True,
                'battery_id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.BEPPPBattery_NotesCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BEPPPBattery_NotesWhereInput] = None,
        cursor: Optional[types.BEPPPBattery_NotesWhereUniqueInput] = None,
    ) -> types.BEPPPBattery_NotesCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.BEPPPBattery_NotesCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BEPPPBattery_NotesWhereInput] = None,
        cursor: Optional[types.BEPPPBattery_NotesWhereUniqueInput] = None,
    ) -> Union[int, types.BEPPPBattery_NotesCountAggregateOutput]:
        """Count the number of BEPPPBattery_Notes records present in the database

        Parameters
        ----------
        select
            Select the BEPPPBattery_Notes fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            BEPPPBattery_Notes filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.BEPPPBattery_NotesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await BEPPPBattery_Notes.prisma().count()

        # results: prisma.types.BEPPPBattery_NotesCountAggregateOutput
        results = await BEPPPBattery_Notes.prisma().count(
            select={
                '_all': True,
                'note_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.BEPPPBattery_NotesCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.BEPPPBattery_NotesWhereInput] = None
    ) -> int:
        """Delete multiple BEPPPBattery_Notes records.

        Parameters
        ----------
        where
            Optional BEPPPBattery_Notes filter to find the records to be deleted

        Returns
        -------
        int
            The total number of BEPPPBattery_Notes records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all BEPPPBattery_Notes records
        total = await BEPPPBattery_Notes.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.BEPPPBattery_NotesScalarFieldKeys'],
        *,
        where: Optional['types.BEPPPBattery_NotesWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.BEPPPBattery_NotesAvgAggregateInput'] = None,
        sum: Optional['types.BEPPPBattery_NotesSumAggregateInput'] = None,
        min: Optional['types.BEPPPBattery_NotesMinAggregateInput'] = None,
        max: Optional['types.BEPPPBattery_NotesMaxAggregateInput'] = None,
        having: Optional['types.BEPPPBattery_NotesScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.BEPPPBattery_NotesCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.BEPPPBattery_NotesScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.BEPPPBattery_NotesScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.BEPPPBattery_NotesGroupByOutput']:
        """Group BEPPPBattery_Notes records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar BEPPPBattery_Notes fields to group records by
        where
            BEPPPBattery_Notes filter to select records
        take
            Limit the maximum number of BEPPPBattery_Notes records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.BEPPPBattery_NotesGroupByOutput]
            A list of dictionaries representing the BEPPPBattery_Notes record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group BEPPPBattery_Notes records by battery_id values
        # and count how many records are in each group
        results = await BEPPPBattery_Notes.prisma().group_by(
            ['battery_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class Rental_NotesActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Rental_Notes]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Rental_Notes.prisma().query_raw(
            'SELECT * FROM Rental_Notes WHERE rental_id = $1',
            11387061048,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Rental_Notes
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Rental_Notes.prisma().query_first(
            'SELECT * FROM Rental_Notes WHERE note_id = $1',
            23579881860,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.Rental_NotesCreateInput,
        include: Optional[types.Rental_NotesInclude] = None
    ) -> _PrismaModelT:
        """Create a new Rental_Notes record.

        Parameters
        ----------
        data
            Rental_Notes record data
        include
            Specifies which relations should be loaded on the returned Rental_Notes model

        Returns
        -------
        prisma.models.Rental_Notes
            The created Rental_Notes record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Rental_Notes record from just the required fields
        rental_notes = await Rental_Notes.prisma().create(
            data={
                # data to create a Rental_Notes record
                'rental_id': 14746701792,
                'note_id': 3062433036,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.Rental_NotesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Rental_Notes records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Rental_Notes record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Rental_Notes.prisma().create_many(
            data=[
                {
                    # data to create a Rental_Notes record
                    'rental_id': 14682886344,
                    'note_id': 6495229908,
                },
                {
                    # data to create a Rental_Notes record
                    'rental_id': 12778160112,
                    'note_id': 6100589532,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.Rental_NotesWhereUniqueInput,
        include: Optional[types.Rental_NotesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Rental_Notes record.

        Parameters
        ----------
        where
            Rental_Notes filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Rental_Notes model

        Returns
        -------
        prisma.models.Rental_Notes
            The deleted Rental_Notes record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        rental_notes = await Rental_Notes.prisma().delete(
            where={
                # Rental_Notes where unique filter

            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.Rental_NotesWhereUniqueInput,
        include: Optional[types.Rental_NotesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Rental_Notes record.

        Parameters
        ----------
        where
            Rental_Notes filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Rental_Notes model

        Returns
        -------
        prisma.models.Rental_Notes
            The found Rental_Notes record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        rental_notes = await Rental_Notes.prisma().find_unique(
            where={
                # Rental_Notes where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.Rental_NotesWhereUniqueInput,
        include: Optional[types.Rental_NotesInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Rental_Notes record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Rental_Notes filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Rental_Notes model

        Returns
        -------
        prisma.models.Rental_Notes
            The found Rental_Notes record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        rental_notes = await Rental_Notes.prisma().find_unique_or_raise(
            where={
                # Rental_Notes where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.Rental_NotesWhereInput] = None,
        cursor: Optional[types.Rental_NotesWhereUniqueInput] = None,
        include: Optional[types.Rental_NotesInclude] = None,
        order: Optional[Union[types.Rental_NotesOrderByInput, List[types.Rental_NotesOrderByInput]]] = None,
        distinct: Optional[List[types.Rental_NotesScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Rental_Notes records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Rental_Notes records returned
        skip
            Ignore the first N results
        where
            Rental_Notes filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Rental_Notes model
        order
            Order the returned Rental_Notes records by any field
        distinct
            Filter Rental_Notes records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Rental_Notes]
            The list of all Rental_Notes records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Rental_Notes records
        rental_notes = await Rental_Notes.prisma().find_many(take=10)

        # find the first 5 Rental_Notes records ordered by the rental_id field
        rental_notes = await Rental_Notes.prisma().find_many(
            take=5,
            order={
                'rental_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.Rental_NotesWhereInput] = None,
        cursor: Optional[types.Rental_NotesWhereUniqueInput] = None,
        include: Optional[types.Rental_NotesInclude] = None,
        order: Optional[Union[types.Rental_NotesOrderByInput, List[types.Rental_NotesOrderByInput]]] = None,
        distinct: Optional[List[types.Rental_NotesScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Rental_Notes record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Rental_Notes filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Rental_Notes model
        order
            Order the returned Rental_Notes records by any field
        distinct
            Filter Rental_Notes records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Rental_Notes
            The first Rental_Notes record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Rental_Notes record ordered by the note_id field
        rental_notes = await Rental_Notes.prisma().find_first(
            skip=1,
            order={
                'note_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.Rental_NotesWhereInput] = None,
        cursor: Optional[types.Rental_NotesWhereUniqueInput] = None,
        include: Optional[types.Rental_NotesInclude] = None,
        order: Optional[Union[types.Rental_NotesOrderByInput, List[types.Rental_NotesOrderByInput]]] = None,
        distinct: Optional[List[types.Rental_NotesScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Rental_Notes record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Rental_Notes filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Rental_Notes model
        order
            Order the returned Rental_Notes records by any field
        distinct
            Filter Rental_Notes records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Rental_Notes
            The first Rental_Notes record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Rental_Notes record ordered by the rental_id field
        rental_notes = await Rental_Notes.prisma().find_first_or_raise(
            skip=1,
            order={
                'rental_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.Rental_NotesUpdateInput,
        where: types.Rental_NotesWhereUniqueInput,
        include: Optional[types.Rental_NotesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Rental_Notes record.

        Parameters
        ----------
        data
            Rental_Notes record data specifying what to update
        where
            Rental_Notes filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Rental_Notes model

        Returns
        -------
        prisma.models.Rental_Notes
            The updated Rental_Notes record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        rental_notes = await Rental_Notes.prisma().update(
            where={
                # Rental_Notes where unique filter

            },
            data={
                # data to update the Rental_Notes record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.Rental_NotesWhereUniqueInput,
        data: types.Rental_NotesUpsertInput,
        include: Optional[types.Rental_NotesInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Rental_Notes filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Rental_Notes model

        Returns
        -------
        prisma.models.Rental_Notes
            The created or updated Rental_Notes record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        rental_notes = await Rental_Notes.prisma().upsert(
            where={
                # Rental_Notes where unique filter
            },
            data={
                'create': {
                    # Rental_Notes data to be set if the record does not exist
                },
                'update': {
                    # Rental_Notes data to be set if the record does exist
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.Rental_NotesUpdateManyMutationInput,
        where: types.Rental_NotesWhereInput,
    ) -> int:
        """Update multiple Rental_Notes records

        Parameters
        ----------
        data
            Rental_Notes data to update the selected Rental_Notes records to
        where
            Filter to select the Rental_Notes records to update

        Returns
        -------
        int
            The total number of Rental_Notes records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Rental_Notes records
        total = await Rental_Notes.prisma().update_many(
            data={
                'note_id': 12291188568
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.Rental_NotesWhereInput] = None,
        cursor: Optional[types.Rental_NotesWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Rental_Notes records present in the database

        Parameters
        ----------
        select
            Select the Rental_Notes fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Rental_Notes filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.Rental_NotesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Rental_Notes.prisma().count()

        # results: prisma.types.Rental_NotesCountAggregateOutput
        results = await Rental_Notes.prisma().count(
            select={
                '_all': True,
                'rental_id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.Rental_NotesCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.Rental_NotesWhereInput] = None,
        cursor: Optional[types.Rental_NotesWhereUniqueInput] = None,
    ) -> types.Rental_NotesCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.Rental_NotesCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.Rental_NotesWhereInput] = None,
        cursor: Optional[types.Rental_NotesWhereUniqueInput] = None,
    ) -> Union[int, types.Rental_NotesCountAggregateOutput]:
        """Count the number of Rental_Notes records present in the database

        Parameters
        ----------
        select
            Select the Rental_Notes fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Rental_Notes filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.Rental_NotesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Rental_Notes.prisma().count()

        # results: prisma.types.Rental_NotesCountAggregateOutput
        results = await Rental_Notes.prisma().count(
            select={
                '_all': True,
                'note_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.Rental_NotesCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.Rental_NotesWhereInput] = None
    ) -> int:
        """Delete multiple Rental_Notes records.

        Parameters
        ----------
        where
            Optional Rental_Notes filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Rental_Notes records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Rental_Notes records
        total = await Rental_Notes.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.Rental_NotesScalarFieldKeys'],
        *,
        where: Optional['types.Rental_NotesWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.Rental_NotesAvgAggregateInput'] = None,
        sum: Optional['types.Rental_NotesSumAggregateInput'] = None,
        min: Optional['types.Rental_NotesMinAggregateInput'] = None,
        max: Optional['types.Rental_NotesMaxAggregateInput'] = None,
        having: Optional['types.Rental_NotesScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.Rental_NotesCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.Rental_NotesScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.Rental_NotesScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.Rental_NotesGroupByOutput']:
        """Group Rental_Notes records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Rental_Notes fields to group records by
        where
            Rental_Notes filter to select records
        take
            Limit the maximum number of Rental_Notes records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.Rental_NotesGroupByOutput]
            A list of dictionaries representing the Rental_Notes record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Rental_Notes records by rental_id values
        # and count how many records are in each group
        results = await Rental_Notes.prisma().group_by(
            ['rental_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PUE_NotesActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.PUE_Notes]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await PUE_Notes.prisma().query_raw(
            'SELECT * FROM PUE_Notes WHERE pue_id = $1',
            10464940836,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.PUE_Notes
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await PUE_Notes.prisma().query_first(
            'SELECT * FROM PUE_Notes WHERE note_id = $1',
            22496977152,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PUE_NotesCreateInput,
        include: Optional[types.PUE_NotesInclude] = None
    ) -> _PrismaModelT:
        """Create a new PUE_Notes record.

        Parameters
        ----------
        data
            PUE_Notes record data
        include
            Specifies which relations should be loaded on the returned PUE_Notes model

        Returns
        -------
        prisma.models.PUE_Notes
            The created PUE_Notes record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a PUE_Notes record from just the required fields
        pue_notes = await PUE_Notes.prisma().create(
            data={
                # data to create a PUE_Notes record
                'pue_id': 11002761132,
                'note_id': 9231210216,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PUE_NotesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple PUE_Notes records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of PUE_Notes record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await PUE_Notes.prisma().create_many(
            data=[
                {
                    # data to create a PUE_Notes record
                    'pue_id': 9843749748,
                    'note_id': 1112736528,
                },
                {
                    # data to create a PUE_Notes record
                    'pue_id': 4138299516,
                    'note_id': 13460893560,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PUE_NotesWhereUniqueInput,
        include: Optional[types.PUE_NotesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single PUE_Notes record.

        Parameters
        ----------
        where
            PUE_Notes filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned PUE_Notes model

        Returns
        -------
        prisma.models.PUE_Notes
            The deleted PUE_Notes record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        pue_notes = await PUE_Notes.prisma().delete(
            where={
                # PUE_Notes where unique filter

            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PUE_NotesWhereUniqueInput,
        include: Optional[types.PUE_NotesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique PUE_Notes record.

        Parameters
        ----------
        where
            PUE_Notes filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PUE_Notes model

        Returns
        -------
        prisma.models.PUE_Notes
            The found PUE_Notes record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        pue_notes = await PUE_Notes.prisma().find_unique(
            where={
                # PUE_Notes where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PUE_NotesWhereUniqueInput,
        include: Optional[types.PUE_NotesInclude] = None
    ) -> _PrismaModelT:
        """Find a unique PUE_Notes record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            PUE_Notes filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PUE_Notes model

        Returns
        -------
        prisma.models.PUE_Notes
            The found PUE_Notes record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        pue_notes = await PUE_Notes.prisma().find_unique_or_raise(
            where={
                # PUE_Notes where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PUE_NotesWhereInput] = None,
        cursor: Optional[types.PUE_NotesWhereUniqueInput] = None,
        include: Optional[types.PUE_NotesInclude] = None,
        order: Optional[Union[types.PUE_NotesOrderByInput, List[types.PUE_NotesOrderByInput]]] = None,
        distinct: Optional[List[types.PUE_NotesScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple PUE_Notes records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of PUE_Notes records returned
        skip
            Ignore the first N results
        where
            PUE_Notes filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PUE_Notes model
        order
            Order the returned PUE_Notes records by any field
        distinct
            Filter PUE_Notes records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.PUE_Notes]
            The list of all PUE_Notes records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 PUE_Notes records
        pue_notes = await PUE_Notes.prisma().find_many(take=10)

        # find the first 5 PUE_Notes records ordered by the pue_id field
        pue_notes = await PUE_Notes.prisma().find_many(
            take=5,
            order={
                'pue_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PUE_NotesWhereInput] = None,
        cursor: Optional[types.PUE_NotesWhereUniqueInput] = None,
        include: Optional[types.PUE_NotesInclude] = None,
        order: Optional[Union[types.PUE_NotesOrderByInput, List[types.PUE_NotesOrderByInput]]] = None,
        distinct: Optional[List[types.PUE_NotesScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single PUE_Notes record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PUE_Notes filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PUE_Notes model
        order
            Order the returned PUE_Notes records by any field
        distinct
            Filter PUE_Notes records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PUE_Notes
            The first PUE_Notes record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PUE_Notes record ordered by the note_id field
        pue_notes = await PUE_Notes.prisma().find_first(
            skip=1,
            order={
                'note_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PUE_NotesWhereInput] = None,
        cursor: Optional[types.PUE_NotesWhereUniqueInput] = None,
        include: Optional[types.PUE_NotesInclude] = None,
        order: Optional[Union[types.PUE_NotesOrderByInput, List[types.PUE_NotesOrderByInput]]] = None,
        distinct: Optional[List[types.PUE_NotesScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single PUE_Notes record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PUE_Notes filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PUE_Notes model
        order
            Order the returned PUE_Notes records by any field
        distinct
            Filter PUE_Notes records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PUE_Notes
            The first PUE_Notes record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PUE_Notes record ordered by the pue_id field
        pue_notes = await PUE_Notes.prisma().find_first_or_raise(
            skip=1,
            order={
                'pue_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PUE_NotesUpdateInput,
        where: types.PUE_NotesWhereUniqueInput,
        include: Optional[types.PUE_NotesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single PUE_Notes record.

        Parameters
        ----------
        data
            PUE_Notes record data specifying what to update
        where
            PUE_Notes filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned PUE_Notes model

        Returns
        -------
        prisma.models.PUE_Notes
            The updated PUE_Notes record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        pue_notes = await PUE_Notes.prisma().update(
            where={
                # PUE_Notes where unique filter

            },
            data={
                # data to update the PUE_Notes record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PUE_NotesWhereUniqueInput,
        data: types.PUE_NotesUpsertInput,
        include: Optional[types.PUE_NotesInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            PUE_Notes filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned PUE_Notes model

        Returns
        -------
        prisma.models.PUE_Notes
            The created or updated PUE_Notes record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        pue_notes = await PUE_Notes.prisma().upsert(
            where={
                # PUE_Notes where unique filter
            },
            data={
                'create': {
                    # PUE_Notes data to be set if the record does not exist
                },
                'update': {
                    # PUE_Notes data to be set if the record does exist
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PUE_NotesUpdateManyMutationInput,
        where: types.PUE_NotesWhereInput,
    ) -> int:
        """Update multiple PUE_Notes records

        Parameters
        ----------
        data
            PUE_Notes data to update the selected PUE_Notes records to
        where
            Filter to select the PUE_Notes records to update

        Returns
        -------
        int
            The total number of PUE_Notes records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all PUE_Notes records
        total = await PUE_Notes.prisma().update_many(
            data={
                'note_id': 17950755012
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PUE_NotesWhereInput] = None,
        cursor: Optional[types.PUE_NotesWhereUniqueInput] = None,
    ) -> int:
        """Count the number of PUE_Notes records present in the database

        Parameters
        ----------
        select
            Select the PUE_Notes fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PUE_Notes filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PUE_NotesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PUE_Notes.prisma().count()

        # results: prisma.types.PUE_NotesCountAggregateOutput
        results = await PUE_Notes.prisma().count(
            select={
                '_all': True,
                'pue_id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PUE_NotesCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PUE_NotesWhereInput] = None,
        cursor: Optional[types.PUE_NotesWhereUniqueInput] = None,
    ) -> types.PUE_NotesCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PUE_NotesCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PUE_NotesWhereInput] = None,
        cursor: Optional[types.PUE_NotesWhereUniqueInput] = None,
    ) -> Union[int, types.PUE_NotesCountAggregateOutput]:
        """Count the number of PUE_Notes records present in the database

        Parameters
        ----------
        select
            Select the PUE_Notes fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PUE_Notes filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PUE_NotesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PUE_Notes.prisma().count()

        # results: prisma.types.PUE_NotesCountAggregateOutput
        results = await PUE_Notes.prisma().count(
            select={
                '_all': True,
                'note_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PUE_NotesCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PUE_NotesWhereInput] = None
    ) -> int:
        """Delete multiple PUE_Notes records.

        Parameters
        ----------
        where
            Optional PUE_Notes filter to find the records to be deleted

        Returns
        -------
        int
            The total number of PUE_Notes records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all PUE_Notes records
        total = await PUE_Notes.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PUE_NotesScalarFieldKeys'],
        *,
        where: Optional['types.PUE_NotesWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PUE_NotesAvgAggregateInput'] = None,
        sum: Optional['types.PUE_NotesSumAggregateInput'] = None,
        min: Optional['types.PUE_NotesMinAggregateInput'] = None,
        max: Optional['types.PUE_NotesMaxAggregateInput'] = None,
        having: Optional['types.PUE_NotesScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PUE_NotesCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PUE_NotesScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.PUE_NotesScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.PUE_NotesGroupByOutput']:
        """Group PUE_Notes records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar PUE_Notes fields to group records by
        where
            PUE_Notes filter to select records
        take
            Limit the maximum number of PUE_Notes records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PUE_NotesGroupByOutput]
            A list of dictionaries representing the PUE_Notes record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group PUE_Notes records by pue_id values
        # and count how many records are in each group
        results = await PUE_Notes.prisma().group_by(
            ['pue_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PUERental_NotesActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.PUERental_Notes]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await PUERental_Notes.prisma().query_raw(
            'SELECT * FROM PUERental_Notes WHERE pue_rental_id = $1',
            2502260256,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.PUERental_Notes
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await PUERental_Notes.prisma().query_first(
            'SELECT * FROM PUERental_Notes WHERE note_id = $1',
            10329738828,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PUERental_NotesCreateInput,
        include: Optional[types.PUERental_NotesInclude] = None
    ) -> _PrismaModelT:
        """Create a new PUERental_Notes record.

        Parameters
        ----------
        data
            PUERental_Notes record data
        include
            Specifies which relations should be loaded on the returned PUERental_Notes model

        Returns
        -------
        prisma.models.PUERental_Notes
            The created PUERental_Notes record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a PUERental_Notes record from just the required fields
        puerental_notes = await PUERental_Notes.prisma().create(
            data={
                # data to create a PUERental_Notes record
                'pue_rental_id': 19931185416,
                'note_id': 6309143316,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PUERental_NotesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple PUERental_Notes records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of PUERental_Notes record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await PUERental_Notes.prisma().create_many(
            data=[
                {
                    # data to create a PUERental_Notes record
                    'pue_rental_id': 8834517552,
                    'note_id': 5926893852,
                },
                {
                    # data to create a PUERental_Notes record
                    'pue_rental_id': 7676238744,
                    'note_id': 7848088164,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PUERental_NotesWhereUniqueInput,
        include: Optional[types.PUERental_NotesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single PUERental_Notes record.

        Parameters
        ----------
        where
            PUERental_Notes filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned PUERental_Notes model

        Returns
        -------
        prisma.models.PUERental_Notes
            The deleted PUERental_Notes record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        puerental_notes = await PUERental_Notes.prisma().delete(
            where={
                # PUERental_Notes where unique filter

            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PUERental_NotesWhereUniqueInput,
        include: Optional[types.PUERental_NotesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique PUERental_Notes record.

        Parameters
        ----------
        where
            PUERental_Notes filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PUERental_Notes model

        Returns
        -------
        prisma.models.PUERental_Notes
            The found PUERental_Notes record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        puerental_notes = await PUERental_Notes.prisma().find_unique(
            where={
                # PUERental_Notes where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PUERental_NotesWhereUniqueInput,
        include: Optional[types.PUERental_NotesInclude] = None
    ) -> _PrismaModelT:
        """Find a unique PUERental_Notes record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            PUERental_Notes filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PUERental_Notes model

        Returns
        -------
        prisma.models.PUERental_Notes
            The found PUERental_Notes record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        puerental_notes = await PUERental_Notes.prisma().find_unique_or_raise(
            where={
                # PUERental_Notes where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PUERental_NotesWhereInput] = None,
        cursor: Optional[types.PUERental_NotesWhereUniqueInput] = None,
        include: Optional[types.PUERental_NotesInclude] = None,
        order: Optional[Union[types.PUERental_NotesOrderByInput, List[types.PUERental_NotesOrderByInput]]] = None,
        distinct: Optional[List[types.PUERental_NotesScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple PUERental_Notes records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of PUERental_Notes records returned
        skip
            Ignore the first N results
        where
            PUERental_Notes filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PUERental_Notes model
        order
            Order the returned PUERental_Notes records by any field
        distinct
            Filter PUERental_Notes records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.PUERental_Notes]
            The list of all PUERental_Notes records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 PUERental_Notes records
        puerental_notes = await PUERental_Notes.prisma().find_many(take=10)

        # find the first 5 PUERental_Notes records ordered by the pue_rental_id field
        puerental_notes = await PUERental_Notes.prisma().find_many(
            take=5,
            order={
                'pue_rental_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PUERental_NotesWhereInput] = None,
        cursor: Optional[types.PUERental_NotesWhereUniqueInput] = None,
        include: Optional[types.PUERental_NotesInclude] = None,
        order: Optional[Union[types.PUERental_NotesOrderByInput, List[types.PUERental_NotesOrderByInput]]] = None,
        distinct: Optional[List[types.PUERental_NotesScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single PUERental_Notes record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PUERental_Notes filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PUERental_Notes model
        order
            Order the returned PUERental_Notes records by any field
        distinct
            Filter PUERental_Notes records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PUERental_Notes
            The first PUERental_Notes record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PUERental_Notes record ordered by the note_id field
        puerental_notes = await PUERental_Notes.prisma().find_first(
            skip=1,
            order={
                'note_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PUERental_NotesWhereInput] = None,
        cursor: Optional[types.PUERental_NotesWhereUniqueInput] = None,
        include: Optional[types.PUERental_NotesInclude] = None,
        order: Optional[Union[types.PUERental_NotesOrderByInput, List[types.PUERental_NotesOrderByInput]]] = None,
        distinct: Optional[List[types.PUERental_NotesScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single PUERental_Notes record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PUERental_Notes filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PUERental_Notes model
        order
            Order the returned PUERental_Notes records by any field
        distinct
            Filter PUERental_Notes records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PUERental_Notes
            The first PUERental_Notes record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PUERental_Notes record ordered by the pue_rental_id field
        puerental_notes = await PUERental_Notes.prisma().find_first_or_raise(
            skip=1,
            order={
                'pue_rental_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PUERental_NotesUpdateInput,
        where: types.PUERental_NotesWhereUniqueInput,
        include: Optional[types.PUERental_NotesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single PUERental_Notes record.

        Parameters
        ----------
        data
            PUERental_Notes record data specifying what to update
        where
            PUERental_Notes filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned PUERental_Notes model

        Returns
        -------
        prisma.models.PUERental_Notes
            The updated PUERental_Notes record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        puerental_notes = await PUERental_Notes.prisma().update(
            where={
                # PUERental_Notes where unique filter

            },
            data={
                # data to update the PUERental_Notes record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PUERental_NotesWhereUniqueInput,
        data: types.PUERental_NotesUpsertInput,
        include: Optional[types.PUERental_NotesInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            PUERental_Notes filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned PUERental_Notes model

        Returns
        -------
        prisma.models.PUERental_Notes
            The created or updated PUERental_Notes record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        puerental_notes = await PUERental_Notes.prisma().upsert(
            where={
                # PUERental_Notes where unique filter
            },
            data={
                'create': {
                    # PUERental_Notes data to be set if the record does not exist
                },
                'update': {
                    # PUERental_Notes data to be set if the record does exist
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PUERental_NotesUpdateManyMutationInput,
        where: types.PUERental_NotesWhereInput,
    ) -> int:
        """Update multiple PUERental_Notes records

        Parameters
        ----------
        data
            PUERental_Notes data to update the selected PUERental_Notes records to
        where
            Filter to select the PUERental_Notes records to update

        Returns
        -------
        int
            The total number of PUERental_Notes records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all PUERental_Notes records
        total = await PUERental_Notes.prisma().update_many(
            data={
                'note_id': 22863138624
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PUERental_NotesWhereInput] = None,
        cursor: Optional[types.PUERental_NotesWhereUniqueInput] = None,
    ) -> int:
        """Count the number of PUERental_Notes records present in the database

        Parameters
        ----------
        select
            Select the PUERental_Notes fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PUERental_Notes filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PUERental_NotesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PUERental_Notes.prisma().count()

        # results: prisma.types.PUERental_NotesCountAggregateOutput
        results = await PUERental_Notes.prisma().count(
            select={
                '_all': True,
                'pue_rental_id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PUERental_NotesCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PUERental_NotesWhereInput] = None,
        cursor: Optional[types.PUERental_NotesWhereUniqueInput] = None,
    ) -> types.PUERental_NotesCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PUERental_NotesCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PUERental_NotesWhereInput] = None,
        cursor: Optional[types.PUERental_NotesWhereUniqueInput] = None,
    ) -> Union[int, types.PUERental_NotesCountAggregateOutput]:
        """Count the number of PUERental_Notes records present in the database

        Parameters
        ----------
        select
            Select the PUERental_Notes fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PUERental_Notes filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PUERental_NotesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PUERental_Notes.prisma().count()

        # results: prisma.types.PUERental_NotesCountAggregateOutput
        results = await PUERental_Notes.prisma().count(
            select={
                '_all': True,
                'note_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PUERental_NotesCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PUERental_NotesWhereInput] = None
    ) -> int:
        """Delete multiple PUERental_Notes records.

        Parameters
        ----------
        where
            Optional PUERental_Notes filter to find the records to be deleted

        Returns
        -------
        int
            The total number of PUERental_Notes records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all PUERental_Notes records
        total = await PUERental_Notes.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PUERental_NotesScalarFieldKeys'],
        *,
        where: Optional['types.PUERental_NotesWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PUERental_NotesAvgAggregateInput'] = None,
        sum: Optional['types.PUERental_NotesSumAggregateInput'] = None,
        min: Optional['types.PUERental_NotesMinAggregateInput'] = None,
        max: Optional['types.PUERental_NotesMaxAggregateInput'] = None,
        having: Optional['types.PUERental_NotesScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PUERental_NotesCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PUERental_NotesScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.PUERental_NotesScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.PUERental_NotesGroupByOutput']:
        """Group PUERental_Notes records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar PUERental_Notes fields to group records by
        where
            PUERental_Notes filter to select records
        take
            Limit the maximum number of PUERental_Notes records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PUERental_NotesGroupByOutput]
            A list of dictionaries representing the PUERental_Notes record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group PUERental_Notes records by pue_rental_id values
        # and count how many records are in each group
        results = await PUERental_Notes.prisma().group_by(
            ['pue_rental_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class BEPPPBatteryActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.BEPPPBattery]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await BEPPPBattery.prisma().query_raw(
            'SELECT * FROM BEPPPBattery WHERE battery_id = $1',
            944963820,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.BEPPPBattery
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await BEPPPBattery.prisma().query_first(
            'SELECT * FROM BEPPPBattery WHERE hub_id = $1',
            16779939624,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.BEPPPBatteryCreateInput,
        include: Optional[types.BEPPPBatteryInclude] = None
    ) -> _PrismaModelT:
        """Create a new BEPPPBattery record.

        Parameters
        ----------
        data
            BEPPPBattery record data
        include
            Specifies which relations should be loaded on the returned BEPPPBattery model

        Returns
        -------
        prisma.models.BEPPPBattery
            The created BEPPPBattery record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a BEPPPBattery record from just the required fields
        bepppbattery = await BEPPPBattery.prisma().create(
            data={
                # data to create a BEPPPBattery record
                'battery_id': 10272007860,
                'hub_id': 17428043088,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.BEPPPBatteryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple BEPPPBattery records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of BEPPPBattery record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await BEPPPBattery.prisma().create_many(
            data=[
                {
                    # data to create a BEPPPBattery record
                    'battery_id': 18878395836,
                    'hub_id': 24166837176,
                },
                {
                    # data to create a BEPPPBattery record
                    'battery_id': 6011580420,
                    'hub_id': 21607492704,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.BEPPPBatteryWhereUniqueInput,
        include: Optional[types.BEPPPBatteryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single BEPPPBattery record.

        Parameters
        ----------
        where
            BEPPPBattery filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned BEPPPBattery model

        Returns
        -------
        prisma.models.BEPPPBattery
            The deleted BEPPPBattery record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        bepppbattery = await BEPPPBattery.prisma().delete(
            where={
                'battery_id': 24924809100,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.BEPPPBatteryWhereUniqueInput,
        include: Optional[types.BEPPPBatteryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique BEPPPBattery record.

        Parameters
        ----------
        where
            BEPPPBattery filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned BEPPPBattery model

        Returns
        -------
        prisma.models.BEPPPBattery
            The found BEPPPBattery record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        bepppbattery = await BEPPPBattery.prisma().find_unique(
            where={
                'battery_id': 20065354056,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.BEPPPBatteryWhereUniqueInput,
        include: Optional[types.BEPPPBatteryInclude] = None
    ) -> _PrismaModelT:
        """Find a unique BEPPPBattery record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            BEPPPBattery filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned BEPPPBattery model

        Returns
        -------
        prisma.models.BEPPPBattery
            The found BEPPPBattery record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        bepppbattery = await BEPPPBattery.prisma().find_unique_or_raise(
            where={
                'battery_id': 11120131668,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BEPPPBatteryWhereInput] = None,
        cursor: Optional[types.BEPPPBatteryWhereUniqueInput] = None,
        include: Optional[types.BEPPPBatteryInclude] = None,
        order: Optional[Union[types.BEPPPBatteryOrderByInput, List[types.BEPPPBatteryOrderByInput]]] = None,
        distinct: Optional[List[types.BEPPPBatteryScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple BEPPPBattery records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of BEPPPBattery records returned
        skip
            Ignore the first N results
        where
            BEPPPBattery filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned BEPPPBattery model
        order
            Order the returned BEPPPBattery records by any field
        distinct
            Filter BEPPPBattery records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.BEPPPBattery]
            The list of all BEPPPBattery records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 BEPPPBattery records
        bepppbatterys = await BEPPPBattery.prisma().find_many(take=10)

        # find the first 5 BEPPPBattery records ordered by the battery_capacity_wh field
        bepppbatterys = await BEPPPBattery.prisma().find_many(
            take=5,
            order={
                'battery_capacity_wh': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.BEPPPBatteryWhereInput] = None,
        cursor: Optional[types.BEPPPBatteryWhereUniqueInput] = None,
        include: Optional[types.BEPPPBatteryInclude] = None,
        order: Optional[Union[types.BEPPPBatteryOrderByInput, List[types.BEPPPBatteryOrderByInput]]] = None,
        distinct: Optional[List[types.BEPPPBatteryScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single BEPPPBattery record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            BEPPPBattery filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned BEPPPBattery model
        order
            Order the returned BEPPPBattery records by any field
        distinct
            Filter BEPPPBattery records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.BEPPPBattery
            The first BEPPPBattery record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second BEPPPBattery record ordered by the status field
        bepppbattery = await BEPPPBattery.prisma().find_first(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.BEPPPBatteryWhereInput] = None,
        cursor: Optional[types.BEPPPBatteryWhereUniqueInput] = None,
        include: Optional[types.BEPPPBatteryInclude] = None,
        order: Optional[Union[types.BEPPPBatteryOrderByInput, List[types.BEPPPBatteryOrderByInput]]] = None,
        distinct: Optional[List[types.BEPPPBatteryScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single BEPPPBattery record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            BEPPPBattery filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned BEPPPBattery model
        order
            Order the returned BEPPPBattery records by any field
        distinct
            Filter BEPPPBattery records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.BEPPPBattery
            The first BEPPPBattery record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second BEPPPBattery record ordered by the battery_id field
        bepppbattery = await BEPPPBattery.prisma().find_first_or_raise(
            skip=1,
            order={
                'battery_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.BEPPPBatteryUpdateInput,
        where: types.BEPPPBatteryWhereUniqueInput,
        include: Optional[types.BEPPPBatteryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single BEPPPBattery record.

        Parameters
        ----------
        data
            BEPPPBattery record data specifying what to update
        where
            BEPPPBattery filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned BEPPPBattery model

        Returns
        -------
        prisma.models.BEPPPBattery
            The updated BEPPPBattery record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        bepppbattery = await BEPPPBattery.prisma().update(
            where={
                'battery_id': 17371489392,
            },
            data={
                # data to update the BEPPPBattery record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.BEPPPBatteryWhereUniqueInput,
        data: types.BEPPPBatteryUpsertInput,
        include: Optional[types.BEPPPBatteryInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            BEPPPBattery filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned BEPPPBattery model

        Returns
        -------
        prisma.models.BEPPPBattery
            The created or updated BEPPPBattery record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        bepppbattery = await BEPPPBattery.prisma().upsert(
            where={
                'battery_id': 20857005660,
            },
            data={
                'create': {
                    'battery_id': 20857005660,
                    'hub_id': 21607492704,
                },
                'update': {
                    'hub_id': 21607492704,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.BEPPPBatteryUpdateManyMutationInput,
        where: types.BEPPPBatteryWhereInput,
    ) -> int:
        """Update multiple BEPPPBattery records

        Parameters
        ----------
        data
            BEPPPBattery data to update the selected BEPPPBattery records to
        where
            Filter to select the BEPPPBattery records to update

        Returns
        -------
        int
            The total number of BEPPPBattery records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all BEPPPBattery records
        total = await BEPPPBattery.prisma().update_many(
            data={
                'hub_id': 4091355096
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BEPPPBatteryWhereInput] = None,
        cursor: Optional[types.BEPPPBatteryWhereUniqueInput] = None,
    ) -> int:
        """Count the number of BEPPPBattery records present in the database

        Parameters
        ----------
        select
            Select the BEPPPBattery fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            BEPPPBattery filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.BEPPPBatteryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await BEPPPBattery.prisma().count()

        # results: prisma.types.BEPPPBatteryCountAggregateOutput
        results = await BEPPPBattery.prisma().count(
            select={
                '_all': True,
                'battery_capacity_wh': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.BEPPPBatteryCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BEPPPBatteryWhereInput] = None,
        cursor: Optional[types.BEPPPBatteryWhereUniqueInput] = None,
    ) -> types.BEPPPBatteryCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.BEPPPBatteryCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BEPPPBatteryWhereInput] = None,
        cursor: Optional[types.BEPPPBatteryWhereUniqueInput] = None,
    ) -> Union[int, types.BEPPPBatteryCountAggregateOutput]:
        """Count the number of BEPPPBattery records present in the database

        Parameters
        ----------
        select
            Select the BEPPPBattery fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            BEPPPBattery filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.BEPPPBatteryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await BEPPPBattery.prisma().count()

        # results: prisma.types.BEPPPBatteryCountAggregateOutput
        results = await BEPPPBattery.prisma().count(
            select={
                '_all': True,
                'status': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.BEPPPBatteryCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.BEPPPBatteryWhereInput] = None
    ) -> int:
        """Delete multiple BEPPPBattery records.

        Parameters
        ----------
        where
            Optional BEPPPBattery filter to find the records to be deleted

        Returns
        -------
        int
            The total number of BEPPPBattery records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all BEPPPBattery records
        total = await BEPPPBattery.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.BEPPPBatteryScalarFieldKeys'],
        *,
        where: Optional['types.BEPPPBatteryWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.BEPPPBatteryAvgAggregateInput'] = None,
        sum: Optional['types.BEPPPBatterySumAggregateInput'] = None,
        min: Optional['types.BEPPPBatteryMinAggregateInput'] = None,
        max: Optional['types.BEPPPBatteryMaxAggregateInput'] = None,
        having: Optional['types.BEPPPBatteryScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.BEPPPBatteryCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.BEPPPBatteryScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.BEPPPBatteryScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.BEPPPBatteryGroupByOutput']:
        """Group BEPPPBattery records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar BEPPPBattery fields to group records by
        where
            BEPPPBattery filter to select records
        take
            Limit the maximum number of BEPPPBattery records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.BEPPPBatteryGroupByOutput]
            A list of dictionaries representing the BEPPPBattery record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group BEPPPBattery records by battery_id values
        # and count how many records are in each group
        results = await BEPPPBattery.prisma().group_by(
            ['battery_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiveDataActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiveData]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiveData.prisma().query_raw(
            'SELECT * FROM LiveData WHERE id = $1',
            7212933540,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiveData
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiveData.prisma().query_first(
            'SELECT * FROM LiveData WHERE battery_id = $1',
            3487239552,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiveDataCreateInput,
        include: Optional[types.LiveDataInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiveData record.

        Parameters
        ----------
        data
            LiveData record data
        include
            Specifies which relations should be loaded on the returned LiveData model

        Returns
        -------
        prisma.models.LiveData
            The created LiveData record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiveData record from just the required fields
        livedata = await LiveData.prisma().create(
            data={
                # data to create a LiveData record
                'id': 22269919788,
                'battery_id': 19332110184,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiveDataCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiveData records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiveData record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiveData.prisma().create_many(
            data=[
                {
                    # data to create a LiveData record
                    'id': 5360085492,
                    'battery_id': 3606820752,
                },
                {
                    # data to create a LiveData record
                    'id': 7591512828,
                    'battery_id': 20688140280,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiveDataWhereUniqueInput,
        include: Optional[types.LiveDataInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiveData record.

        Parameters
        ----------
        where
            LiveData filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiveData model

        Returns
        -------
        prisma.models.LiveData
            The deleted LiveData record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        livedata = await LiveData.prisma().delete(
            where={
                'id': 5641889604,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiveDataWhereUniqueInput,
        include: Optional[types.LiveDataInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiveData record.

        Parameters
        ----------
        where
            LiveData filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiveData model

        Returns
        -------
        prisma.models.LiveData
            The found LiveData record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        livedata = await LiveData.prisma().find_unique(
            where={
                'id': 14510518944,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiveDataWhereUniqueInput,
        include: Optional[types.LiveDataInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiveData record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiveData filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiveData model

        Returns
        -------
        prisma.models.LiveData
            The found LiveData record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        livedata = await LiveData.prisma().find_unique_or_raise(
            where={
                'id': 18440933580,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiveDataWhereInput] = None,
        cursor: Optional[types.LiveDataWhereUniqueInput] = None,
        include: Optional[types.LiveDataInclude] = None,
        order: Optional[Union[types.LiveDataOrderByInput, List[types.LiveDataOrderByInput]]] = None,
        distinct: Optional[List[types.LiveDataScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiveData records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiveData records returned
        skip
            Ignore the first N results
        where
            LiveData filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiveData model
        order
            Order the returned LiveData records by any field
        distinct
            Filter LiveData records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiveData]
            The list of all LiveData records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiveData records
        livedatas = await LiveData.prisma().find_many(take=10)

        # find the first 5 LiveData records ordered by the state_of_charge field
        livedatas = await LiveData.prisma().find_many(
            take=5,
            order={
                'state_of_charge': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiveDataWhereInput] = None,
        cursor: Optional[types.LiveDataWhereUniqueInput] = None,
        include: Optional[types.LiveDataInclude] = None,
        order: Optional[Union[types.LiveDataOrderByInput, List[types.LiveDataOrderByInput]]] = None,
        distinct: Optional[List[types.LiveDataScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiveData record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiveData filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiveData model
        order
            Order the returned LiveData records by any field
        distinct
            Filter LiveData records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiveData
            The first LiveData record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiveData record ordered by the voltage field
        livedata = await LiveData.prisma().find_first(
            skip=1,
            order={
                'voltage': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiveDataWhereInput] = None,
        cursor: Optional[types.LiveDataWhereUniqueInput] = None,
        include: Optional[types.LiveDataInclude] = None,
        order: Optional[Union[types.LiveDataOrderByInput, List[types.LiveDataOrderByInput]]] = None,
        distinct: Optional[List[types.LiveDataScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiveData record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiveData filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiveData model
        order
            Order the returned LiveData records by any field
        distinct
            Filter LiveData records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiveData
            The first LiveData record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiveData record ordered by the current_amps field
        livedata = await LiveData.prisma().find_first_or_raise(
            skip=1,
            order={
                'current_amps': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiveDataUpdateInput,
        where: types.LiveDataWhereUniqueInput,
        include: Optional[types.LiveDataInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiveData record.

        Parameters
        ----------
        data
            LiveData record data specifying what to update
        where
            LiveData filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiveData model

        Returns
        -------
        prisma.models.LiveData
            The updated LiveData record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        livedata = await LiveData.prisma().update(
            where={
                'id': 5090627976,
            },
            data={
                # data to update the LiveData record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiveDataWhereUniqueInput,
        data: types.LiveDataUpsertInput,
        include: Optional[types.LiveDataInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiveData filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiveData model

        Returns
        -------
        prisma.models.LiveData
            The created or updated LiveData record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        livedata = await LiveData.prisma().upsert(
            where={
                'id': 25507588500,
            },
            data={
                'create': {
                    'id': 25507588500,
                    'battery_id': 20688140280,
                },
                'update': {
                    'battery_id': 20688140280,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiveDataUpdateManyMutationInput,
        where: types.LiveDataWhereInput,
    ) -> int:
        """Update multiple LiveData records

        Parameters
        ----------
        data
            LiveData data to update the selected LiveData records to
        where
            Filter to select the LiveData records to update

        Returns
        -------
        int
            The total number of LiveData records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiveData records
        total = await LiveData.prisma().update_many(
            data={
                'power_watts': 536951780.92472
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiveDataWhereInput] = None,
        cursor: Optional[types.LiveDataWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiveData records present in the database

        Parameters
        ----------
        select
            Select the LiveData fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiveData filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiveDataCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiveData.prisma().count()

        # results: prisma.types.LiveDataCountAggregateOutput
        results = await LiveData.prisma().count(
            select={
                '_all': True,
                'time_remaining': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiveDataCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiveDataWhereInput] = None,
        cursor: Optional[types.LiveDataWhereUniqueInput] = None,
    ) -> types.LiveDataCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiveDataCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiveDataWhereInput] = None,
        cursor: Optional[types.LiveDataWhereUniqueInput] = None,
    ) -> Union[int, types.LiveDataCountAggregateOutput]:
        """Count the number of LiveData records present in the database

        Parameters
        ----------
        select
            Select the LiveData fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiveData filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiveDataCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiveData.prisma().count()

        # results: prisma.types.LiveDataCountAggregateOutput
        results = await LiveData.prisma().count(
            select={
                '_all': True,
                'temp_battery': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiveDataCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiveDataWhereInput] = None
    ) -> int:
        """Delete multiple LiveData records.

        Parameters
        ----------
        where
            Optional LiveData filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiveData records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiveData records
        total = await LiveData.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiveDataScalarFieldKeys'],
        *,
        where: Optional['types.LiveDataWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiveDataAvgAggregateInput'] = None,
        sum: Optional['types.LiveDataSumAggregateInput'] = None,
        min: Optional['types.LiveDataMinAggregateInput'] = None,
        max: Optional['types.LiveDataMaxAggregateInput'] = None,
        having: Optional['types.LiveDataScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiveDataCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiveDataScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiveDataScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiveDataGroupByOutput']:
        """Group LiveData records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiveData fields to group records by
        where
            LiveData filter to select records
        take
            Limit the maximum number of LiveData records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiveDataGroupByOutput]
            A list of dictionaries representing the LiveData record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiveData records by amp_hours_consumed values
        # and count how many records are in each group
        results = await LiveData.prisma().group_by(
            ['amp_hours_consumed'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class RentalActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Rental]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Rental.prisma().query_raw(
            'SELECT * FROM Rental WHERE rentral_id = $1',
            19463255064,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Rental
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Rental.prisma().query_first(
            'SELECT * FROM Rental WHERE battery_id = $1',
            22185984228,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.RentalCreateInput,
        include: Optional[types.RentalInclude] = None
    ) -> _PrismaModelT:
        """Create a new Rental record.

        Parameters
        ----------
        data
            Rental record data
        include
            Specifies which relations should be loaded on the returned Rental model

        Returns
        -------
        prisma.models.Rental
            The created Rental record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Rental record from just the required fields
        rental = await Rental.prisma().create(
            data={
                # data to create a Rental record
                'rentral_id': 23058340800,
                'battery_id': 25205134188,
                'user_id': 10189680552,
                'timestamp_taken': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.RentalCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Rental records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Rental record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Rental.prisma().create_many(
            data=[
                {
                    # data to create a Rental record
                    'rentral_id': 11137826100,
                    'battery_id': 3276384720,
                    'user_id': 11794182204,
                    'timestamp_taken': datetime.datetime.utcnow(),
                },
                {
                    # data to create a Rental record
                    'rentral_id': 6128849976,
                    'battery_id': 25409859204,
                    'user_id': 16823339232,
                    'timestamp_taken': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.RentalWhereUniqueInput,
        include: Optional[types.RentalInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Rental record.

        Parameters
        ----------
        where
            Rental filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Rental model

        Returns
        -------
        prisma.models.Rental
            The deleted Rental record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        rental = await Rental.prisma().delete(
            where={
                'rentral_id': 15571290636,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.RentalWhereUniqueInput,
        include: Optional[types.RentalInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Rental record.

        Parameters
        ----------
        where
            Rental filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Rental model

        Returns
        -------
        prisma.models.Rental
            The found Rental record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        rental = await Rental.prisma().find_unique(
            where={
                'rentral_id': 6233862600,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.RentalWhereUniqueInput,
        include: Optional[types.RentalInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Rental record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Rental filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Rental model

        Returns
        -------
        prisma.models.Rental
            The found Rental record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        rental = await Rental.prisma().find_unique_or_raise(
            where={
                'rentral_id': 11721991380,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RentalWhereInput] = None,
        cursor: Optional[types.RentalWhereUniqueInput] = None,
        include: Optional[types.RentalInclude] = None,
        order: Optional[Union[types.RentalOrderByInput, List[types.RentalOrderByInput]]] = None,
        distinct: Optional[List[types.RentalScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Rental records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Rental records returned
        skip
            Ignore the first N results
        where
            Rental filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Rental model
        order
            Order the returned Rental records by any field
        distinct
            Filter Rental records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Rental]
            The list of all Rental records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Rental records
        rentals = await Rental.prisma().find_many(take=10)

        # find the first 5 Rental records ordered by the user_id field
        rentals = await Rental.prisma().find_many(
            take=5,
            order={
                'user_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.RentalWhereInput] = None,
        cursor: Optional[types.RentalWhereUniqueInput] = None,
        include: Optional[types.RentalInclude] = None,
        order: Optional[Union[types.RentalOrderByInput, List[types.RentalOrderByInput]]] = None,
        distinct: Optional[List[types.RentalScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Rental record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Rental filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Rental model
        order
            Order the returned Rental records by any field
        distinct
            Filter Rental records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Rental
            The first Rental record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Rental record ordered by the timestamp_taken field
        rental = await Rental.prisma().find_first(
            skip=1,
            order={
                'timestamp_taken': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.RentalWhereInput] = None,
        cursor: Optional[types.RentalWhereUniqueInput] = None,
        include: Optional[types.RentalInclude] = None,
        order: Optional[Union[types.RentalOrderByInput, List[types.RentalOrderByInput]]] = None,
        distinct: Optional[List[types.RentalScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Rental record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Rental filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Rental model
        order
            Order the returned Rental records by any field
        distinct
            Filter Rental records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Rental
            The first Rental record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Rental record ordered by the due_back field
        rental = await Rental.prisma().find_first_or_raise(
            skip=1,
            order={
                'due_back': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.RentalUpdateInput,
        where: types.RentalWhereUniqueInput,
        include: Optional[types.RentalInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Rental record.

        Parameters
        ----------
        data
            Rental record data specifying what to update
        where
            Rental filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Rental model

        Returns
        -------
        prisma.models.Rental
            The updated Rental record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        rental = await Rental.prisma().update(
            where={
                'rentral_id': 20357105904,
            },
            data={
                # data to update the Rental record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.RentalWhereUniqueInput,
        data: types.RentalUpsertInput,
        include: Optional[types.RentalInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Rental filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Rental model

        Returns
        -------
        prisma.models.Rental
            The created or updated Rental record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        rental = await Rental.prisma().upsert(
            where={
                'rentral_id': 2031153372,
            },
            data={
                'create': {
                    'rentral_id': 2031153372,
                    'battery_id': 25409859204,
                    'user_id': 16823339232,
                    'timestamp_taken': datetime.datetime.utcnow(),
                },
                'update': {
                    'battery_id': 25409859204,
                    'user_id': 16823339232,
                    'timestamp_taken': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.RentalUpdateManyMutationInput,
        where: types.RentalWhereInput,
    ) -> int:
        """Update multiple Rental records

        Parameters
        ----------
        data
            Rental data to update the selected Rental records to
        where
            Filter to select the Rental records to update

        Returns
        -------
        int
            The total number of Rental records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Rental records
        total = await Rental.prisma().update_many(
            data={
                'date_returned': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RentalWhereInput] = None,
        cursor: Optional[types.RentalWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Rental records present in the database

        Parameters
        ----------
        select
            Select the Rental fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Rental filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.RentalCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Rental.prisma().count()

        # results: prisma.types.RentalCountAggregateOutput
        results = await Rental.prisma().count(
            select={
                '_all': True,
                'rentral_id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.RentalCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RentalWhereInput] = None,
        cursor: Optional[types.RentalWhereUniqueInput] = None,
    ) -> types.RentalCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.RentalCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RentalWhereInput] = None,
        cursor: Optional[types.RentalWhereUniqueInput] = None,
    ) -> Union[int, types.RentalCountAggregateOutput]:
        """Count the number of Rental records present in the database

        Parameters
        ----------
        select
            Select the Rental fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Rental filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.RentalCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Rental.prisma().count()

        # results: prisma.types.RentalCountAggregateOutput
        results = await Rental.prisma().count(
            select={
                '_all': True,
                'battery_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.RentalCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.RentalWhereInput] = None
    ) -> int:
        """Delete multiple Rental records.

        Parameters
        ----------
        where
            Optional Rental filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Rental records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Rental records
        total = await Rental.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.RentalScalarFieldKeys'],
        *,
        where: Optional['types.RentalWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.RentalAvgAggregateInput'] = None,
        sum: Optional['types.RentalSumAggregateInput'] = None,
        min: Optional['types.RentalMinAggregateInput'] = None,
        max: Optional['types.RentalMaxAggregateInput'] = None,
        having: Optional['types.RentalScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.RentalCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.RentalScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.RentalScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.RentalGroupByOutput']:
        """Group Rental records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Rental fields to group records by
        where
            Rental filter to select records
        take
            Limit the maximum number of Rental records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.RentalGroupByOutput]
            A list of dictionaries representing the Rental record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Rental records by user_id values
        # and count how many records are in each group
        results = await Rental.prisma().group_by(
            ['user_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ProductiveUseEquipmentActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ProductiveUseEquipment]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ProductiveUseEquipment.prisma().query_raw(
            'SELECT * FROM ProductiveUseEquipment WHERE pue_id = $1',
            12276979800,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ProductiveUseEquipment
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ProductiveUseEquipment.prisma().query_first(
            'SELECT * FROM ProductiveUseEquipment WHERE hub_id = $1',
            3932172324,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ProductiveUseEquipmentCreateInput,
        include: Optional[types.ProductiveUseEquipmentInclude] = None
    ) -> _PrismaModelT:
        """Create a new ProductiveUseEquipment record.

        Parameters
        ----------
        data
            ProductiveUseEquipment record data
        include
            Specifies which relations should be loaded on the returned ProductiveUseEquipment model

        Returns
        -------
        prisma.models.ProductiveUseEquipment
            The created ProductiveUseEquipment record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ProductiveUseEquipment record from just the required fields
        productiveuseequipment = await ProductiveUseEquipment.prisma().create(
            data={
                # data to create a ProductiveUseEquipment record
                'pue_id': 6332987904,
                'hub_id': 24352289964,
                'name': 'bdbifjhbbi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ProductiveUseEquipmentCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ProductiveUseEquipment records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ProductiveUseEquipment record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ProductiveUseEquipment.prisma().create_many(
            data=[
                {
                    # data to create a ProductiveUseEquipment record
                    'pue_id': 25465348212,
                    'hub_id': 12299316240,
                    'name': 'bhbhdahfaj',
                },
                {
                    # data to create a ProductiveUseEquipment record
                    'pue_id': 19177488504,
                    'hub_id': 9811477956,
                    'name': 'badaffhddg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ProductiveUseEquipmentWhereUniqueInput,
        include: Optional[types.ProductiveUseEquipmentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ProductiveUseEquipment record.

        Parameters
        ----------
        where
            ProductiveUseEquipment filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ProductiveUseEquipment model

        Returns
        -------
        prisma.models.ProductiveUseEquipment
            The deleted ProductiveUseEquipment record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        productiveuseequipment = await ProductiveUseEquipment.prisma().delete(
            where={
                'pue_id': 13578310476,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ProductiveUseEquipmentWhereUniqueInput,
        include: Optional[types.ProductiveUseEquipmentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ProductiveUseEquipment record.

        Parameters
        ----------
        where
            ProductiveUseEquipment filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ProductiveUseEquipment model

        Returns
        -------
        prisma.models.ProductiveUseEquipment
            The found ProductiveUseEquipment record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        productiveuseequipment = await ProductiveUseEquipment.prisma().find_unique(
            where={
                'pue_id': 2527994376,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ProductiveUseEquipmentWhereUniqueInput,
        include: Optional[types.ProductiveUseEquipmentInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ProductiveUseEquipment record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ProductiveUseEquipment filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ProductiveUseEquipment model

        Returns
        -------
        prisma.models.ProductiveUseEquipment
            The found ProductiveUseEquipment record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        productiveuseequipment = await ProductiveUseEquipment.prisma().find_unique_or_raise(
            where={
                'pue_id': 15312695316,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProductiveUseEquipmentWhereInput] = None,
        cursor: Optional[types.ProductiveUseEquipmentWhereUniqueInput] = None,
        include: Optional[types.ProductiveUseEquipmentInclude] = None,
        order: Optional[Union[types.ProductiveUseEquipmentOrderByInput, List[types.ProductiveUseEquipmentOrderByInput]]] = None,
        distinct: Optional[List[types.ProductiveUseEquipmentScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ProductiveUseEquipment records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ProductiveUseEquipment records returned
        skip
            Ignore the first N results
        where
            ProductiveUseEquipment filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ProductiveUseEquipment model
        order
            Order the returned ProductiveUseEquipment records by any field
        distinct
            Filter ProductiveUseEquipment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ProductiveUseEquipment]
            The list of all ProductiveUseEquipment records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ProductiveUseEquipment records
        productiveuseequipments = await ProductiveUseEquipment.prisma().find_many(take=10)

        # find the first 5 ProductiveUseEquipment records ordered by the name field
        productiveuseequipments = await ProductiveUseEquipment.prisma().find_many(
            take=5,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProductiveUseEquipmentWhereInput] = None,
        cursor: Optional[types.ProductiveUseEquipmentWhereUniqueInput] = None,
        include: Optional[types.ProductiveUseEquipmentInclude] = None,
        order: Optional[Union[types.ProductiveUseEquipmentOrderByInput, List[types.ProductiveUseEquipmentOrderByInput]]] = None,
        distinct: Optional[List[types.ProductiveUseEquipmentScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ProductiveUseEquipment record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ProductiveUseEquipment filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ProductiveUseEquipment model
        order
            Order the returned ProductiveUseEquipment records by any field
        distinct
            Filter ProductiveUseEquipment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ProductiveUseEquipment
            The first ProductiveUseEquipment record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ProductiveUseEquipment record ordered by the description field
        productiveuseequipment = await ProductiveUseEquipment.prisma().find_first(
            skip=1,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProductiveUseEquipmentWhereInput] = None,
        cursor: Optional[types.ProductiveUseEquipmentWhereUniqueInput] = None,
        include: Optional[types.ProductiveUseEquipmentInclude] = None,
        order: Optional[Union[types.ProductiveUseEquipmentOrderByInput, List[types.ProductiveUseEquipmentOrderByInput]]] = None,
        distinct: Optional[List[types.ProductiveUseEquipmentScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ProductiveUseEquipment record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ProductiveUseEquipment filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ProductiveUseEquipment model
        order
            Order the returned ProductiveUseEquipment records by any field
        distinct
            Filter ProductiveUseEquipment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ProductiveUseEquipment
            The first ProductiveUseEquipment record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ProductiveUseEquipment record ordered by the rental_cost field
        productiveuseequipment = await ProductiveUseEquipment.prisma().find_first_or_raise(
            skip=1,
            order={
                'rental_cost': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ProductiveUseEquipmentUpdateInput,
        where: types.ProductiveUseEquipmentWhereUniqueInput,
        include: Optional[types.ProductiveUseEquipmentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ProductiveUseEquipment record.

        Parameters
        ----------
        data
            ProductiveUseEquipment record data specifying what to update
        where
            ProductiveUseEquipment filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ProductiveUseEquipment model

        Returns
        -------
        prisma.models.ProductiveUseEquipment
            The updated ProductiveUseEquipment record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        productiveuseequipment = await ProductiveUseEquipment.prisma().update(
            where={
                'pue_id': 8946832176,
            },
            data={
                # data to update the ProductiveUseEquipment record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ProductiveUseEquipmentWhereUniqueInput,
        data: types.ProductiveUseEquipmentUpsertInput,
        include: Optional[types.ProductiveUseEquipmentInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ProductiveUseEquipment filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ProductiveUseEquipment model

        Returns
        -------
        prisma.models.ProductiveUseEquipment
            The created or updated ProductiveUseEquipment record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        productiveuseequipment = await ProductiveUseEquipment.prisma().upsert(
            where={
                'pue_id': 3694513692,
            },
            data={
                'create': {
                    'pue_id': 3694513692,
                    'hub_id': 9811477956,
                    'name': 'badaffhddg',
                },
                'update': {
                    'hub_id': 9811477956,
                    'name': 'badaffhddg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ProductiveUseEquipmentUpdateManyMutationInput,
        where: types.ProductiveUseEquipmentWhereInput,
    ) -> int:
        """Update multiple ProductiveUseEquipment records

        Parameters
        ----------
        data
            ProductiveUseEquipment data to update the selected ProductiveUseEquipment records to
        where
            Filter to select the ProductiveUseEquipment records to update

        Returns
        -------
        int
            The total number of ProductiveUseEquipment records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ProductiveUseEquipment records
        total = await ProductiveUseEquipment.prisma().update_many(
            data={
                'status': 'bgheaejbcc'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProductiveUseEquipmentWhereInput] = None,
        cursor: Optional[types.ProductiveUseEquipmentWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ProductiveUseEquipment records present in the database

        Parameters
        ----------
        select
            Select the ProductiveUseEquipment fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ProductiveUseEquipment filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProductiveUseEquipmentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ProductiveUseEquipment.prisma().count()

        # results: prisma.types.ProductiveUseEquipmentCountAggregateOutput
        results = await ProductiveUseEquipment.prisma().count(
            select={
                '_all': True,
                'rental_count': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ProductiveUseEquipmentCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProductiveUseEquipmentWhereInput] = None,
        cursor: Optional[types.ProductiveUseEquipmentWhereUniqueInput] = None,
    ) -> types.ProductiveUseEquipmentCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ProductiveUseEquipmentCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProductiveUseEquipmentWhereInput] = None,
        cursor: Optional[types.ProductiveUseEquipmentWhereUniqueInput] = None,
    ) -> Union[int, types.ProductiveUseEquipmentCountAggregateOutput]:
        """Count the number of ProductiveUseEquipment records present in the database

        Parameters
        ----------
        select
            Select the ProductiveUseEquipment fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ProductiveUseEquipment filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProductiveUseEquipmentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ProductiveUseEquipment.prisma().count()

        # results: prisma.types.ProductiveUseEquipmentCountAggregateOutput
        results = await ProductiveUseEquipment.prisma().count(
            select={
                '_all': True,
                'pue_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ProductiveUseEquipmentCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ProductiveUseEquipmentWhereInput] = None
    ) -> int:
        """Delete multiple ProductiveUseEquipment records.

        Parameters
        ----------
        where
            Optional ProductiveUseEquipment filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ProductiveUseEquipment records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ProductiveUseEquipment records
        total = await ProductiveUseEquipment.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ProductiveUseEquipmentScalarFieldKeys'],
        *,
        where: Optional['types.ProductiveUseEquipmentWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ProductiveUseEquipmentAvgAggregateInput'] = None,
        sum: Optional['types.ProductiveUseEquipmentSumAggregateInput'] = None,
        min: Optional['types.ProductiveUseEquipmentMinAggregateInput'] = None,
        max: Optional['types.ProductiveUseEquipmentMaxAggregateInput'] = None,
        having: Optional['types.ProductiveUseEquipmentScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ProductiveUseEquipmentCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ProductiveUseEquipmentScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ProductiveUseEquipmentScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ProductiveUseEquipmentGroupByOutput']:
        """Group ProductiveUseEquipment records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ProductiveUseEquipment fields to group records by
        where
            ProductiveUseEquipment filter to select records
        take
            Limit the maximum number of ProductiveUseEquipment records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ProductiveUseEquipmentGroupByOutput]
            A list of dictionaries representing the ProductiveUseEquipment record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ProductiveUseEquipment records by hub_id values
        # and count how many records are in each group
        results = await ProductiveUseEquipment.prisma().group_by(
            ['hub_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PUERentalActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.PUERental]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await PUERental.prisma().query_raw(
            'SELECT * FROM PUERental WHERE pue_rental_id = $1',
            18322255716,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.PUERental
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await PUERental.prisma().query_first(
            'SELECT * FROM PUERental WHERE pue_id = $1',
            11496925248,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PUERentalCreateInput,
        include: Optional[types.PUERentalInclude] = None
    ) -> _PrismaModelT:
        """Create a new PUERental record.

        Parameters
        ----------
        data
            PUERental record data
        include
            Specifies which relations should be loaded on the returned PUERental model

        Returns
        -------
        prisma.models.PUERental
            The created PUERental record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a PUERental record from just the required fields
        puerental = await PUERental.prisma().create(
            data={
                # data to create a PUERental record
                'pue_rental_id': 18156611052,
                'pue_id': 2456096808,
                'user_id': 24811819956,
                'timestamp_taken': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PUERentalCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple PUERental records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of PUERental record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await PUERental.prisma().create_many(
            data=[
                {
                    # data to create a PUERental record
                    'pue_rental_id': 14206942800,
                    'pue_id': 19076459196,
                    'user_id': 14921710776,
                    'timestamp_taken': datetime.datetime.utcnow(),
                },
                {
                    # data to create a PUERental record
                    'pue_rental_id': 16437947652,
                    'pue_id': 20143121760,
                    'user_id': 4842253452,
                    'timestamp_taken': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PUERentalWhereUniqueInput,
        include: Optional[types.PUERentalInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single PUERental record.

        Parameters
        ----------
        where
            PUERental filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned PUERental model

        Returns
        -------
        prisma.models.PUERental
            The deleted PUERental record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        puerental = await PUERental.prisma().delete(
            where={
                'pue_rental_id': 7785128520,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PUERentalWhereUniqueInput,
        include: Optional[types.PUERentalInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique PUERental record.

        Parameters
        ----------
        where
            PUERental filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PUERental model

        Returns
        -------
        prisma.models.PUERental
            The found PUERental record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        puerental = await PUERental.prisma().find_unique(
            where={
                'pue_rental_id': 7287884628,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PUERentalWhereUniqueInput,
        include: Optional[types.PUERentalInclude] = None
    ) -> _PrismaModelT:
        """Find a unique PUERental record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            PUERental filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PUERental model

        Returns
        -------
        prisma.models.PUERental
            The found PUERental record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        puerental = await PUERental.prisma().find_unique_or_raise(
            where={
                'pue_rental_id': 17626688880,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PUERentalWhereInput] = None,
        cursor: Optional[types.PUERentalWhereUniqueInput] = None,
        include: Optional[types.PUERentalInclude] = None,
        order: Optional[Union[types.PUERentalOrderByInput, List[types.PUERentalOrderByInput]]] = None,
        distinct: Optional[List[types.PUERentalScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple PUERental records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of PUERental records returned
        skip
            Ignore the first N results
        where
            PUERental filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PUERental model
        order
            Order the returned PUERental records by any field
        distinct
            Filter PUERental records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.PUERental]
            The list of all PUERental records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 PUERental records
        puerentals = await PUERental.prisma().find_many(take=10)

        # find the first 5 PUERental records ordered by the user_id field
        puerentals = await PUERental.prisma().find_many(
            take=5,
            order={
                'user_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PUERentalWhereInput] = None,
        cursor: Optional[types.PUERentalWhereUniqueInput] = None,
        include: Optional[types.PUERentalInclude] = None,
        order: Optional[Union[types.PUERentalOrderByInput, List[types.PUERentalOrderByInput]]] = None,
        distinct: Optional[List[types.PUERentalScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single PUERental record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PUERental filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PUERental model
        order
            Order the returned PUERental records by any field
        distinct
            Filter PUERental records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PUERental
            The first PUERental record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PUERental record ordered by the timestamp_taken field
        puerental = await PUERental.prisma().find_first(
            skip=1,
            order={
                'timestamp_taken': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PUERentalWhereInput] = None,
        cursor: Optional[types.PUERentalWhereUniqueInput] = None,
        include: Optional[types.PUERentalInclude] = None,
        order: Optional[Union[types.PUERentalOrderByInput, List[types.PUERentalOrderByInput]]] = None,
        distinct: Optional[List[types.PUERentalScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single PUERental record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PUERental filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PUERental model
        order
            Order the returned PUERental records by any field
        distinct
            Filter PUERental records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PUERental
            The first PUERental record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PUERental record ordered by the due_back field
        puerental = await PUERental.prisma().find_first_or_raise(
            skip=1,
            order={
                'due_back': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PUERentalUpdateInput,
        where: types.PUERentalWhereUniqueInput,
        include: Optional[types.PUERentalInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single PUERental record.

        Parameters
        ----------
        data
            PUERental record data specifying what to update
        where
            PUERental filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned PUERental model

        Returns
        -------
        prisma.models.PUERental
            The updated PUERental record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        puerental = await PUERental.prisma().update(
            where={
                'pue_rental_id': 7548468060,
            },
            data={
                # data to update the PUERental record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PUERentalWhereUniqueInput,
        data: types.PUERentalUpsertInput,
        include: Optional[types.PUERentalInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            PUERental filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned PUERental model

        Returns
        -------
        prisma.models.PUERental
            The created or updated PUERental record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        puerental = await PUERental.prisma().upsert(
            where={
                'pue_rental_id': 14570016984,
            },
            data={
                'create': {
                    'pue_rental_id': 14570016984,
                    'pue_id': 20143121760,
                    'user_id': 4842253452,
                    'timestamp_taken': datetime.datetime.utcnow(),
                },
                'update': {
                    'pue_id': 20143121760,
                    'user_id': 4842253452,
                    'timestamp_taken': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PUERentalUpdateManyMutationInput,
        where: types.PUERentalWhereInput,
    ) -> int:
        """Update multiple PUERental records

        Parameters
        ----------
        data
            PUERental data to update the selected PUERental records to
        where
            Filter to select the PUERental records to update

        Returns
        -------
        int
            The total number of PUERental records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all PUERental records
        total = await PUERental.prisma().update_many(
            data={
                'date_returned': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PUERentalWhereInput] = None,
        cursor: Optional[types.PUERentalWhereUniqueInput] = None,
    ) -> int:
        """Count the number of PUERental records present in the database

        Parameters
        ----------
        select
            Select the PUERental fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PUERental filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PUERentalCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PUERental.prisma().count()

        # results: prisma.types.PUERentalCountAggregateOutput
        results = await PUERental.prisma().count(
            select={
                '_all': True,
                'pue_rental_id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PUERentalCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PUERentalWhereInput] = None,
        cursor: Optional[types.PUERentalWhereUniqueInput] = None,
    ) -> types.PUERentalCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PUERentalCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PUERentalWhereInput] = None,
        cursor: Optional[types.PUERentalWhereUniqueInput] = None,
    ) -> Union[int, types.PUERentalCountAggregateOutput]:
        """Count the number of PUERental records present in the database

        Parameters
        ----------
        select
            Select the PUERental fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PUERental filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PUERentalCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PUERental.prisma().count()

        # results: prisma.types.PUERentalCountAggregateOutput
        results = await PUERental.prisma().count(
            select={
                '_all': True,
                'pue_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PUERentalCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PUERentalWhereInput] = None
    ) -> int:
        """Delete multiple PUERental records.

        Parameters
        ----------
        where
            Optional PUERental filter to find the records to be deleted

        Returns
        -------
        int
            The total number of PUERental records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all PUERental records
        total = await PUERental.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PUERentalScalarFieldKeys'],
        *,
        where: Optional['types.PUERentalWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PUERentalAvgAggregateInput'] = None,
        sum: Optional['types.PUERentalSumAggregateInput'] = None,
        min: Optional['types.PUERentalMinAggregateInput'] = None,
        max: Optional['types.PUERentalMaxAggregateInput'] = None,
        having: Optional['types.PUERentalScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PUERentalCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PUERentalScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.PUERentalScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.PUERentalGroupByOutput']:
        """Group PUERental records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar PUERental fields to group records by
        where
            PUERental filter to select records
        take
            Limit the maximum number of PUERental records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PUERentalGroupByOutput]
            A list of dictionaries representing the PUERental record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group PUERental records by user_id values
        # and count how many records are in each group
        results = await PUERental.prisma().group_by(
            ['user_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class BatteryPUERentalActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.BatteryPUERental]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await BatteryPUERental.prisma().query_raw(
            'SELECT * FROM BatteryPUERental WHERE battery_rental_id = $1',
            10783358628,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.BatteryPUERental
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await BatteryPUERental.prisma().query_first(
            'SELECT * FROM BatteryPUERental WHERE pue_rental_id = $1',
            7900538496,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.BatteryPUERentalCreateInput,
        include: Optional[types.BatteryPUERentalInclude] = None
    ) -> _PrismaModelT:
        """Create a new BatteryPUERental record.

        Parameters
        ----------
        data
            BatteryPUERental record data
        include
            Specifies which relations should be loaded on the returned BatteryPUERental model

        Returns
        -------
        prisma.models.BatteryPUERental
            The created BatteryPUERental record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a BatteryPUERental record from just the required fields
        batterypuerental = await BatteryPUERental.prisma().create(
            data={
                # data to create a BatteryPUERental record
                'battery_rental_id': 11455440684,
                'pue_rental_id': 14577719400,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.BatteryPUERentalCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple BatteryPUERental records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of BatteryPUERental record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await BatteryPUERental.prisma().create_many(
            data=[
                {
                    # data to create a BatteryPUERental record
                    'battery_rental_id': 12573841140,
                    'pue_rental_id': 15632818320,
                },
                {
                    # data to create a BatteryPUERental record
                    'battery_rental_id': 10716626940,
                    'pue_rental_id': 3360999672,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.BatteryPUERentalWhereUniqueInput,
        include: Optional[types.BatteryPUERentalInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single BatteryPUERental record.

        Parameters
        ----------
        where
            BatteryPUERental filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned BatteryPUERental model

        Returns
        -------
        prisma.models.BatteryPUERental
            The deleted BatteryPUERental record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        batterypuerental = await BatteryPUERental.prisma().delete(
            where={
                # BatteryPUERental where unique filter

            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.BatteryPUERentalWhereUniqueInput,
        include: Optional[types.BatteryPUERentalInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique BatteryPUERental record.

        Parameters
        ----------
        where
            BatteryPUERental filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned BatteryPUERental model

        Returns
        -------
        prisma.models.BatteryPUERental
            The found BatteryPUERental record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        batterypuerental = await BatteryPUERental.prisma().find_unique(
            where={
                # BatteryPUERental where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.BatteryPUERentalWhereUniqueInput,
        include: Optional[types.BatteryPUERentalInclude] = None
    ) -> _PrismaModelT:
        """Find a unique BatteryPUERental record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            BatteryPUERental filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned BatteryPUERental model

        Returns
        -------
        prisma.models.BatteryPUERental
            The found BatteryPUERental record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        batterypuerental = await BatteryPUERental.prisma().find_unique_or_raise(
            where={
                # BatteryPUERental where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BatteryPUERentalWhereInput] = None,
        cursor: Optional[types.BatteryPUERentalWhereUniqueInput] = None,
        include: Optional[types.BatteryPUERentalInclude] = None,
        order: Optional[Union[types.BatteryPUERentalOrderByInput, List[types.BatteryPUERentalOrderByInput]]] = None,
        distinct: Optional[List[types.BatteryPUERentalScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple BatteryPUERental records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of BatteryPUERental records returned
        skip
            Ignore the first N results
        where
            BatteryPUERental filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned BatteryPUERental model
        order
            Order the returned BatteryPUERental records by any field
        distinct
            Filter BatteryPUERental records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.BatteryPUERental]
            The list of all BatteryPUERental records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 BatteryPUERental records
        batterypuerentals = await BatteryPUERental.prisma().find_many(take=10)

        # find the first 5 BatteryPUERental records ordered by the battery_rental_id field
        batterypuerentals = await BatteryPUERental.prisma().find_many(
            take=5,
            order={
                'battery_rental_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.BatteryPUERentalWhereInput] = None,
        cursor: Optional[types.BatteryPUERentalWhereUniqueInput] = None,
        include: Optional[types.BatteryPUERentalInclude] = None,
        order: Optional[Union[types.BatteryPUERentalOrderByInput, List[types.BatteryPUERentalOrderByInput]]] = None,
        distinct: Optional[List[types.BatteryPUERentalScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single BatteryPUERental record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            BatteryPUERental filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned BatteryPUERental model
        order
            Order the returned BatteryPUERental records by any field
        distinct
            Filter BatteryPUERental records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.BatteryPUERental
            The first BatteryPUERental record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second BatteryPUERental record ordered by the pue_rental_id field
        batterypuerental = await BatteryPUERental.prisma().find_first(
            skip=1,
            order={
                'pue_rental_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.BatteryPUERentalWhereInput] = None,
        cursor: Optional[types.BatteryPUERentalWhereUniqueInput] = None,
        include: Optional[types.BatteryPUERentalInclude] = None,
        order: Optional[Union[types.BatteryPUERentalOrderByInput, List[types.BatteryPUERentalOrderByInput]]] = None,
        distinct: Optional[List[types.BatteryPUERentalScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single BatteryPUERental record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            BatteryPUERental filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned BatteryPUERental model
        order
            Order the returned BatteryPUERental records by any field
        distinct
            Filter BatteryPUERental records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.BatteryPUERental
            The first BatteryPUERental record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second BatteryPUERental record ordered by the battery_rental_id field
        batterypuerental = await BatteryPUERental.prisma().find_first_or_raise(
            skip=1,
            order={
                'battery_rental_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.BatteryPUERentalUpdateInput,
        where: types.BatteryPUERentalWhereUniqueInput,
        include: Optional[types.BatteryPUERentalInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single BatteryPUERental record.

        Parameters
        ----------
        data
            BatteryPUERental record data specifying what to update
        where
            BatteryPUERental filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned BatteryPUERental model

        Returns
        -------
        prisma.models.BatteryPUERental
            The updated BatteryPUERental record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        batterypuerental = await BatteryPUERental.prisma().update(
            where={
                # BatteryPUERental where unique filter

            },
            data={
                # data to update the BatteryPUERental record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.BatteryPUERentalWhereUniqueInput,
        data: types.BatteryPUERentalUpsertInput,
        include: Optional[types.BatteryPUERentalInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            BatteryPUERental filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned BatteryPUERental model

        Returns
        -------
        prisma.models.BatteryPUERental
            The created or updated BatteryPUERental record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        batterypuerental = await BatteryPUERental.prisma().upsert(
            where={
                # BatteryPUERental where unique filter
            },
            data={
                'create': {
                    # BatteryPUERental data to be set if the record does not exist
                },
                'update': {
                    # BatteryPUERental data to be set if the record does exist
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.BatteryPUERentalUpdateManyMutationInput,
        where: types.BatteryPUERentalWhereInput,
    ) -> int:
        """Update multiple BatteryPUERental records

        Parameters
        ----------
        data
            BatteryPUERental data to update the selected BatteryPUERental records to
        where
            Filter to select the BatteryPUERental records to update

        Returns
        -------
        int
            The total number of BatteryPUERental records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all BatteryPUERental records
        total = await BatteryPUERental.prisma().update_many(
            data={
                'pue_rental_id': 6596027460
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BatteryPUERentalWhereInput] = None,
        cursor: Optional[types.BatteryPUERentalWhereUniqueInput] = None,
    ) -> int:
        """Count the number of BatteryPUERental records present in the database

        Parameters
        ----------
        select
            Select the BatteryPUERental fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            BatteryPUERental filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.BatteryPUERentalCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await BatteryPUERental.prisma().count()

        # results: prisma.types.BatteryPUERentalCountAggregateOutput
        results = await BatteryPUERental.prisma().count(
            select={
                '_all': True,
                'battery_rental_id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.BatteryPUERentalCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BatteryPUERentalWhereInput] = None,
        cursor: Optional[types.BatteryPUERentalWhereUniqueInput] = None,
    ) -> types.BatteryPUERentalCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.BatteryPUERentalCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BatteryPUERentalWhereInput] = None,
        cursor: Optional[types.BatteryPUERentalWhereUniqueInput] = None,
    ) -> Union[int, types.BatteryPUERentalCountAggregateOutput]:
        """Count the number of BatteryPUERental records present in the database

        Parameters
        ----------
        select
            Select the BatteryPUERental fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            BatteryPUERental filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.BatteryPUERentalCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await BatteryPUERental.prisma().count()

        # results: prisma.types.BatteryPUERentalCountAggregateOutput
        results = await BatteryPUERental.prisma().count(
            select={
                '_all': True,
                'pue_rental_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.BatteryPUERentalCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.BatteryPUERentalWhereInput] = None
    ) -> int:
        """Delete multiple BatteryPUERental records.

        Parameters
        ----------
        where
            Optional BatteryPUERental filter to find the records to be deleted

        Returns
        -------
        int
            The total number of BatteryPUERental records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all BatteryPUERental records
        total = await BatteryPUERental.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.BatteryPUERentalScalarFieldKeys'],
        *,
        where: Optional['types.BatteryPUERentalWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.BatteryPUERentalAvgAggregateInput'] = None,
        sum: Optional['types.BatteryPUERentalSumAggregateInput'] = None,
        min: Optional['types.BatteryPUERentalMinAggregateInput'] = None,
        max: Optional['types.BatteryPUERentalMaxAggregateInput'] = None,
        having: Optional['types.BatteryPUERentalScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.BatteryPUERentalCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.BatteryPUERentalScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.BatteryPUERentalScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.BatteryPUERentalGroupByOutput']:
        """Group BatteryPUERental records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar BatteryPUERental fields to group records by
        where
            BatteryPUERental filter to select records
        take
            Limit the maximum number of BatteryPUERental records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.BatteryPUERentalGroupByOutput]
            A list of dictionaries representing the BatteryPUERental record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group BatteryPUERental records by battery_rental_id values
        # and count how many records are in each group
        results = await BatteryPUERental.prisma().group_by(
            ['battery_rental_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models