# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template models.py.jinja --
import os
import logging
import inspect
import warnings
from collections import OrderedDict

from pydantic import BaseModel, Field

from . import types, enums, errors, fields, bases
from ._types import FuncType
from ._compat import model_rebuild, field_validator
from ._builder import serialize_base64
from .generator import partial_models_ctx, PartialModelField


log: logging.Logger = logging.getLogger(__name__)
_created_partial_types: Set[str] = set()

class SolarHub(bases.BaseSolarHub):
    """Represents a SolarHub record"""

    hub_id: _int
    what_three_word_location: Optional[_str] = None
    solar_capacity_kw: Optional[_int] = None
    country: Optional[_str] = None
    latitude: Optional[_float] = None
    longitude: Optional[_float] = None
    users: Optional[List['models.User']] = None
    batteries: Optional[List['models.BEPPPBattery']] = None
    pue_items: Optional[List['models.ProductiveUseEquipment']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.SolarHubKeys']] = None,
        exclude: Optional[Iterable['types.SolarHubKeys']] = None,
        required: Optional[Iterable['types.SolarHubKeys']] = None,
        optional: Optional[Iterable['types.SolarHubKeys']] = None,
        relations: Optional[Mapping['types.SolarHubRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.SolarHubKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _SolarHub_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _SolarHub_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _SolarHub_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _SolarHub_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _SolarHub_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _SolarHub_relational_fields:
                        raise errors.UnknownRelationalFieldError('SolarHub', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid SolarHub / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'SolarHub',
            }
        )
        _created_partial_types.add(name)


class User(bases.BaseUser):
    """Represents a User record"""

    user_id: _int
    Name: _str
    users_identification_document_number: Optional[_str] = None
    mobile_number: Optional[_str] = None
    address: Optional[_str] = None
    hub_id: _int
    user_access_level: _str
    username: _str
    password_hash: _str
    hub: Optional['models.SolarHub'] = None
    battery_rentals: Optional[List['models.Rental']] = None
    pue_rentals: Optional[List['models.PUERental']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.UserKeys']] = None,
        exclude: Optional[Iterable['types.UserKeys']] = None,
        required: Optional[Iterable['types.UserKeys']] = None,
        optional: Optional[Iterable['types.UserKeys']] = None,
        relations: Optional[Mapping['types.UserRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.UserKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _User_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _User_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _User_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _User_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _User_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _User_relational_fields:
                        raise errors.UnknownRelationalFieldError('User', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid User / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'User',
            }
        )
        _created_partial_types.add(name)


class Note(bases.BaseNote):
    """Represents a Note record"""

    id: _int
    content: _str
    created_at: datetime.datetime
    batteries: Optional[List['models.BEPPPBattery_Notes']] = None
    rentals: Optional[List['models.Rental_Notes']] = None
    pue_items: Optional[List['models.PUE_Notes']] = None
    pue_rentals: Optional[List['models.PUERental_Notes']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.NoteKeys']] = None,
        exclude: Optional[Iterable['types.NoteKeys']] = None,
        required: Optional[Iterable['types.NoteKeys']] = None,
        optional: Optional[Iterable['types.NoteKeys']] = None,
        relations: Optional[Mapping['types.NoteRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.NoteKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Note_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Note_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Note_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Note_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Note_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Note_relational_fields:
                        raise errors.UnknownRelationalFieldError('Note', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Note / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Note',
            }
        )
        _created_partial_types.add(name)


class BEPPPBattery_Notes(bases.BaseBEPPPBattery_Notes):
    """Represents a BEPPPBattery_Notes record"""

    battery_id: _int
    note_id: _int
    battery: Optional['models.BEPPPBattery'] = None
    note: Optional['models.Note'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.BEPPPBattery_NotesKeys']] = None,
        exclude: Optional[Iterable['types.BEPPPBattery_NotesKeys']] = None,
        required: Optional[Iterable['types.BEPPPBattery_NotesKeys']] = None,
        optional: Optional[Iterable['types.BEPPPBattery_NotesKeys']] = None,
        relations: Optional[Mapping['types.BEPPPBattery_NotesRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.BEPPPBattery_NotesKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _BEPPPBattery_Notes_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _BEPPPBattery_Notes_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _BEPPPBattery_Notes_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _BEPPPBattery_Notes_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _BEPPPBattery_Notes_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _BEPPPBattery_Notes_relational_fields:
                        raise errors.UnknownRelationalFieldError('BEPPPBattery_Notes', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid BEPPPBattery_Notes / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'BEPPPBattery_Notes',
            }
        )
        _created_partial_types.add(name)


class Rental_Notes(bases.BaseRental_Notes):
    """Represents a Rental_Notes record"""

    rental_id: _int
    note_id: _int
    rental: Optional['models.Rental'] = None
    note: Optional['models.Note'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.Rental_NotesKeys']] = None,
        exclude: Optional[Iterable['types.Rental_NotesKeys']] = None,
        required: Optional[Iterable['types.Rental_NotesKeys']] = None,
        optional: Optional[Iterable['types.Rental_NotesKeys']] = None,
        relations: Optional[Mapping['types.Rental_NotesRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.Rental_NotesKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Rental_Notes_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Rental_Notes_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Rental_Notes_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Rental_Notes_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Rental_Notes_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Rental_Notes_relational_fields:
                        raise errors.UnknownRelationalFieldError('Rental_Notes', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Rental_Notes / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Rental_Notes',
            }
        )
        _created_partial_types.add(name)


class PUE_Notes(bases.BasePUE_Notes):
    """Represents a PUE_Notes record"""

    pue_id: _int
    note_id: _int
    pue: Optional['models.ProductiveUseEquipment'] = None
    note: Optional['models.Note'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.PUE_NotesKeys']] = None,
        exclude: Optional[Iterable['types.PUE_NotesKeys']] = None,
        required: Optional[Iterable['types.PUE_NotesKeys']] = None,
        optional: Optional[Iterable['types.PUE_NotesKeys']] = None,
        relations: Optional[Mapping['types.PUE_NotesRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.PUE_NotesKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _PUE_Notes_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _PUE_Notes_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _PUE_Notes_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _PUE_Notes_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _PUE_Notes_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _PUE_Notes_relational_fields:
                        raise errors.UnknownRelationalFieldError('PUE_Notes', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid PUE_Notes / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'PUE_Notes',
            }
        )
        _created_partial_types.add(name)


class PUERental_Notes(bases.BasePUERental_Notes):
    """Represents a PUERental_Notes record"""

    pue_rental_id: _int
    note_id: _int
    pue_rental: Optional['models.PUERental'] = None
    note: Optional['models.Note'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.PUERental_NotesKeys']] = None,
        exclude: Optional[Iterable['types.PUERental_NotesKeys']] = None,
        required: Optional[Iterable['types.PUERental_NotesKeys']] = None,
        optional: Optional[Iterable['types.PUERental_NotesKeys']] = None,
        relations: Optional[Mapping['types.PUERental_NotesRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.PUERental_NotesKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _PUERental_Notes_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _PUERental_Notes_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _PUERental_Notes_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _PUERental_Notes_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _PUERental_Notes_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _PUERental_Notes_relational_fields:
                        raise errors.UnknownRelationalFieldError('PUERental_Notes', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid PUERental_Notes / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'PUERental_Notes',
            }
        )
        _created_partial_types.add(name)


class BEPPPBattery(bases.BaseBEPPPBattery):
    """Represents a BEPPPBattery record"""

    battery_id: _int
    hub_id: _int
    battery_capacity_wh: Optional[_int] = None
    status: Optional[_str] = None
    hub: Optional['models.SolarHub'] = None
    live_data: Optional[List['models.LiveData']] = None
    rentals: Optional[List['models.Rental']] = None
    notes: Optional[List['models.BEPPPBattery_Notes']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.BEPPPBatteryKeys']] = None,
        exclude: Optional[Iterable['types.BEPPPBatteryKeys']] = None,
        required: Optional[Iterable['types.BEPPPBatteryKeys']] = None,
        optional: Optional[Iterable['types.BEPPPBatteryKeys']] = None,
        relations: Optional[Mapping['types.BEPPPBatteryRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.BEPPPBatteryKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _BEPPPBattery_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _BEPPPBattery_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _BEPPPBattery_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _BEPPPBattery_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _BEPPPBattery_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _BEPPPBattery_relational_fields:
                        raise errors.UnknownRelationalFieldError('BEPPPBattery', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid BEPPPBattery / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'BEPPPBattery',
            }
        )
        _created_partial_types.add(name)


class LiveData(bases.BaseLiveData):
    """Represents a LiveData record"""

    id: _int
    battery_id: _int
    state_of_charge: Optional[_int] = None
    voltage: Optional[_float] = None
    current_amps: Optional[_float] = None
    power_watts: Optional[_float] = None
    time_remaining: Optional[_int] = None
    temp_battery: Optional[_float] = None
    amp_hours_consumed: Optional[_float] = None
    charging_current: Optional[_float] = None
    timestamp: Optional[datetime.datetime] = None
    usb_voltage: Optional[_float] = None
    usb_power: Optional[_float] = None
    usb_current: Optional[_float] = None
    latitude: Optional[_float] = None
    longitude: Optional[_float] = None
    altitude: Optional[_float] = None
    SD_card_storage_remaining: Optional[_float] = None
    battery_orientation: Optional[_str] = None
    number_GPS_satellites_for_fix: Optional[_int] = None
    mobile_signal_strength: Optional[_int] = None
    event_type: Optional[_str] = None
    new_battery_cycle: Optional[_int] = None
    battery: Optional['models.BEPPPBattery'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiveDataKeys']] = None,
        exclude: Optional[Iterable['types.LiveDataKeys']] = None,
        required: Optional[Iterable['types.LiveDataKeys']] = None,
        optional: Optional[Iterable['types.LiveDataKeys']] = None,
        relations: Optional[Mapping['types.LiveDataRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiveDataKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiveData_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiveData_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiveData_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiveData_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _LiveData_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _LiveData_relational_fields:
                        raise errors.UnknownRelationalFieldError('LiveData', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiveData / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiveData',
            }
        )
        _created_partial_types.add(name)


class Rental(bases.BaseRental):
    """Represents a Rental record"""

    rentral_id: _int
    battery_id: _int
    user_id: _int
    timestamp_taken: datetime.datetime
    due_back: Optional[datetime.datetime] = None
    date_returned: Optional[datetime.datetime] = None
    battery: Optional['models.BEPPPBattery'] = None
    user: Optional['models.User'] = None
    notes: Optional[List['models.Rental_Notes']] = None
    pue_rentals: Optional[List['models.BatteryPUERental']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.RentalKeys']] = None,
        exclude: Optional[Iterable['types.RentalKeys']] = None,
        required: Optional[Iterable['types.RentalKeys']] = None,
        optional: Optional[Iterable['types.RentalKeys']] = None,
        relations: Optional[Mapping['types.RentalRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.RentalKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Rental_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Rental_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Rental_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Rental_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Rental_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Rental_relational_fields:
                        raise errors.UnknownRelationalFieldError('Rental', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Rental / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Rental',
            }
        )
        _created_partial_types.add(name)


class ProductiveUseEquipment(bases.BaseProductiveUseEquipment):
    """Represents a ProductiveUseEquipment record"""

    pue_id: _int
    hub_id: _int
    name: _str
    description: Optional[_str] = None
    rental_cost: Optional[_float] = None
    status: Optional[_str] = None
    rental_count: _int
    hub: Optional['models.SolarHub'] = None
    notes: Optional[List['models.PUE_Notes']] = None
    pue_rentals: Optional[List['models.PUERental']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ProductiveUseEquipmentKeys']] = None,
        exclude: Optional[Iterable['types.ProductiveUseEquipmentKeys']] = None,
        required: Optional[Iterable['types.ProductiveUseEquipmentKeys']] = None,
        optional: Optional[Iterable['types.ProductiveUseEquipmentKeys']] = None,
        relations: Optional[Mapping['types.ProductiveUseEquipmentRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ProductiveUseEquipmentKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _ProductiveUseEquipment_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _ProductiveUseEquipment_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _ProductiveUseEquipment_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _ProductiveUseEquipment_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _ProductiveUseEquipment_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _ProductiveUseEquipment_relational_fields:
                        raise errors.UnknownRelationalFieldError('ProductiveUseEquipment', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid ProductiveUseEquipment / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'ProductiveUseEquipment',
            }
        )
        _created_partial_types.add(name)


class PUERental(bases.BasePUERental):
    """Represents a PUERental record"""

    pue_rental_id: _int
    pue_id: _int
    user_id: _int
    timestamp_taken: datetime.datetime
    due_back: Optional[datetime.datetime] = None
    date_returned: Optional[datetime.datetime] = None
    pue: Optional['models.ProductiveUseEquipment'] = None
    user: Optional['models.User'] = None
    notes: Optional[List['models.PUERental_Notes']] = None
    battery_rentals: Optional[List['models.BatteryPUERental']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.PUERentalKeys']] = None,
        exclude: Optional[Iterable['types.PUERentalKeys']] = None,
        required: Optional[Iterable['types.PUERentalKeys']] = None,
        optional: Optional[Iterable['types.PUERentalKeys']] = None,
        relations: Optional[Mapping['types.PUERentalRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.PUERentalKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _PUERental_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _PUERental_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _PUERental_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _PUERental_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _PUERental_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _PUERental_relational_fields:
                        raise errors.UnknownRelationalFieldError('PUERental', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid PUERental / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'PUERental',
            }
        )
        _created_partial_types.add(name)


class BatteryPUERental(bases.BaseBatteryPUERental):
    """Represents a BatteryPUERental record"""

    battery_rental_id: _int
    pue_rental_id: _int
    battery_rental: Optional['models.Rental'] = None
    pue_rental: Optional['models.PUERental'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.BatteryPUERentalKeys']] = None,
        exclude: Optional[Iterable['types.BatteryPUERentalKeys']] = None,
        required: Optional[Iterable['types.BatteryPUERentalKeys']] = None,
        optional: Optional[Iterable['types.BatteryPUERentalKeys']] = None,
        relations: Optional[Mapping['types.BatteryPUERentalRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.BatteryPUERentalKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _BatteryPUERental_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _BatteryPUERental_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _BatteryPUERental_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _BatteryPUERental_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _BatteryPUERental_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _BatteryPUERental_relational_fields:
                        raise errors.UnknownRelationalFieldError('BatteryPUERental', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid BatteryPUERental / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'BatteryPUERental',
            }
        )
        _created_partial_types.add(name)



_SolarHub_relational_fields: Set[str] = {
        'users',
        'batteries',
        'pue_items',
    }
_SolarHub_fields: Dict['types.SolarHubKeys', PartialModelField] = OrderedDict(
    [
        ('hub_id', {
            'name': 'hub_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('what_three_word_location', {
            'name': 'what_three_word_location',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('solar_capacity_kw', {
            'name': 'solar_capacity_kw',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('country', {
            'name': 'country',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('latitude', {
            'name': 'latitude',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('longitude', {
            'name': 'longitude',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('users', {
            'name': 'users',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.User\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('batteries', {
            'name': 'batteries',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.BEPPPBattery\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('pue_items', {
            'name': 'pue_items',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ProductiveUseEquipment\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_User_relational_fields: Set[str] = {
        'hub',
        'battery_rentals',
        'pue_rentals',
    }
_User_fields: Dict['types.UserKeys', PartialModelField] = OrderedDict(
    [
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('Name', {
            'name': 'Name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('users_identification_document_number', {
            'name': 'users_identification_document_number',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('mobile_number', {
            'name': 'mobile_number',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('address', {
            'name': 'address',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('hub_id', {
            'name': 'hub_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('user_access_level', {
            'name': 'user_access_level',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('username', {
            'name': 'username',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('password_hash', {
            'name': 'password_hash',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('hub', {
            'name': 'hub',
            'is_list': False,
            'optional': True,
            'type': 'models.SolarHub',
            'is_relational': True,
            'documentation': None,
        }),
        ('battery_rentals', {
            'name': 'battery_rentals',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Rental\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('pue_rentals', {
            'name': 'pue_rentals',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.PUERental\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Note_relational_fields: Set[str] = {
        'batteries',
        'rentals',
        'pue_items',
        'pue_rentals',
    }
_Note_fields: Dict['types.NoteKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('content', {
            'name': 'content',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('batteries', {
            'name': 'batteries',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.BEPPPBattery_Notes\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('rentals', {
            'name': 'rentals',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Rental_Notes\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('pue_items', {
            'name': 'pue_items',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.PUE_Notes\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('pue_rentals', {
            'name': 'pue_rentals',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.PUERental_Notes\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_BEPPPBattery_Notes_relational_fields: Set[str] = {
        'battery',
        'note',
    }
_BEPPPBattery_Notes_fields: Dict['types.BEPPPBattery_NotesKeys', PartialModelField] = OrderedDict(
    [
        ('battery_id', {
            'name': 'battery_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('note_id', {
            'name': 'note_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('battery', {
            'name': 'battery',
            'is_list': False,
            'optional': True,
            'type': 'models.BEPPPBattery',
            'is_relational': True,
            'documentation': None,
        }),
        ('note', {
            'name': 'note',
            'is_list': False,
            'optional': True,
            'type': 'models.Note',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Rental_Notes_relational_fields: Set[str] = {
        'rental',
        'note',
    }
_Rental_Notes_fields: Dict['types.Rental_NotesKeys', PartialModelField] = OrderedDict(
    [
        ('rental_id', {
            'name': 'rental_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('note_id', {
            'name': 'note_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('rental', {
            'name': 'rental',
            'is_list': False,
            'optional': True,
            'type': 'models.Rental',
            'is_relational': True,
            'documentation': None,
        }),
        ('note', {
            'name': 'note',
            'is_list': False,
            'optional': True,
            'type': 'models.Note',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_PUE_Notes_relational_fields: Set[str] = {
        'pue',
        'note',
    }
_PUE_Notes_fields: Dict['types.PUE_NotesKeys', PartialModelField] = OrderedDict(
    [
        ('pue_id', {
            'name': 'pue_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('note_id', {
            'name': 'note_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('pue', {
            'name': 'pue',
            'is_list': False,
            'optional': True,
            'type': 'models.ProductiveUseEquipment',
            'is_relational': True,
            'documentation': None,
        }),
        ('note', {
            'name': 'note',
            'is_list': False,
            'optional': True,
            'type': 'models.Note',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_PUERental_Notes_relational_fields: Set[str] = {
        'pue_rental',
        'note',
    }
_PUERental_Notes_fields: Dict['types.PUERental_NotesKeys', PartialModelField] = OrderedDict(
    [
        ('pue_rental_id', {
            'name': 'pue_rental_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('note_id', {
            'name': 'note_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('pue_rental', {
            'name': 'pue_rental',
            'is_list': False,
            'optional': True,
            'type': 'models.PUERental',
            'is_relational': True,
            'documentation': None,
        }),
        ('note', {
            'name': 'note',
            'is_list': False,
            'optional': True,
            'type': 'models.Note',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_BEPPPBattery_relational_fields: Set[str] = {
        'hub',
        'live_data',
        'rentals',
        'notes',
    }
_BEPPPBattery_fields: Dict['types.BEPPPBatteryKeys', PartialModelField] = OrderedDict(
    [
        ('battery_id', {
            'name': 'battery_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('hub_id', {
            'name': 'hub_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('battery_capacity_wh', {
            'name': 'battery_capacity_wh',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('hub', {
            'name': 'hub',
            'is_list': False,
            'optional': True,
            'type': 'models.SolarHub',
            'is_relational': True,
            'documentation': None,
        }),
        ('live_data', {
            'name': 'live_data',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.LiveData\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('rentals', {
            'name': 'rentals',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Rental\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('notes', {
            'name': 'notes',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.BEPPPBattery_Notes\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_LiveData_relational_fields: Set[str] = {
        'battery',
    }
_LiveData_fields: Dict['types.LiveDataKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('battery_id', {
            'name': 'battery_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('state_of_charge', {
            'name': 'state_of_charge',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('voltage', {
            'name': 'voltage',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('current_amps', {
            'name': 'current_amps',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('power_watts', {
            'name': 'power_watts',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('time_remaining', {
            'name': 'time_remaining',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('temp_battery', {
            'name': 'temp_battery',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('amp_hours_consumed', {
            'name': 'amp_hours_consumed',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('charging_current', {
            'name': 'charging_current',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('timestamp', {
            'name': 'timestamp',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('usb_voltage', {
            'name': 'usb_voltage',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('usb_power', {
            'name': 'usb_power',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('usb_current', {
            'name': 'usb_current',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('latitude', {
            'name': 'latitude',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('longitude', {
            'name': 'longitude',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('altitude', {
            'name': 'altitude',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('SD_card_storage_remaining', {
            'name': 'SD_card_storage_remaining',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('battery_orientation', {
            'name': 'battery_orientation',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('number_GPS_satellites_for_fix', {
            'name': 'number_GPS_satellites_for_fix',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('mobile_signal_strength', {
            'name': 'mobile_signal_strength',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('event_type', {
            'name': 'event_type',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('new_battery_cycle', {
            'name': 'new_battery_cycle',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('battery', {
            'name': 'battery',
            'is_list': False,
            'optional': True,
            'type': 'models.BEPPPBattery',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Rental_relational_fields: Set[str] = {
        'battery',
        'user',
        'notes',
        'pue_rentals',
    }
_Rental_fields: Dict['types.RentalKeys', PartialModelField] = OrderedDict(
    [
        ('rentral_id', {
            'name': 'rentral_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('battery_id', {
            'name': 'battery_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('timestamp_taken', {
            'name': 'timestamp_taken',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('due_back', {
            'name': 'due_back',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('date_returned', {
            'name': 'date_returned',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('battery', {
            'name': 'battery',
            'is_list': False,
            'optional': True,
            'type': 'models.BEPPPBattery',
            'is_relational': True,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('notes', {
            'name': 'notes',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Rental_Notes\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('pue_rentals', {
            'name': 'pue_rentals',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.BatteryPUERental\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_ProductiveUseEquipment_relational_fields: Set[str] = {
        'hub',
        'notes',
        'pue_rentals',
    }
_ProductiveUseEquipment_fields: Dict['types.ProductiveUseEquipmentKeys', PartialModelField] = OrderedDict(
    [
        ('pue_id', {
            'name': 'pue_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('hub_id', {
            'name': 'hub_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('rental_cost', {
            'name': 'rental_cost',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('rental_count', {
            'name': 'rental_count',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('hub', {
            'name': 'hub',
            'is_list': False,
            'optional': True,
            'type': 'models.SolarHub',
            'is_relational': True,
            'documentation': None,
        }),
        ('notes', {
            'name': 'notes',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.PUE_Notes\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('pue_rentals', {
            'name': 'pue_rentals',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.PUERental\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_PUERental_relational_fields: Set[str] = {
        'pue',
        'user',
        'notes',
        'battery_rentals',
    }
_PUERental_fields: Dict['types.PUERentalKeys', PartialModelField] = OrderedDict(
    [
        ('pue_rental_id', {
            'name': 'pue_rental_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('pue_id', {
            'name': 'pue_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('timestamp_taken', {
            'name': 'timestamp_taken',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('due_back', {
            'name': 'due_back',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('date_returned', {
            'name': 'date_returned',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('pue', {
            'name': 'pue',
            'is_list': False,
            'optional': True,
            'type': 'models.ProductiveUseEquipment',
            'is_relational': True,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('notes', {
            'name': 'notes',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.PUERental_Notes\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('battery_rentals', {
            'name': 'battery_rentals',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.BatteryPUERental\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_BatteryPUERental_relational_fields: Set[str] = {
        'battery_rental',
        'pue_rental',
    }
_BatteryPUERental_fields: Dict['types.BatteryPUERentalKeys', PartialModelField] = OrderedDict(
    [
        ('battery_rental_id', {
            'name': 'battery_rental_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('pue_rental_id', {
            'name': 'pue_rental_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('battery_rental', {
            'name': 'battery_rental',
            'is_list': False,
            'optional': True,
            'type': 'models.Rental',
            'is_relational': True,
            'documentation': None,
        }),
        ('pue_rental', {
            'name': 'pue_rental',
            'is_list': False,
            'optional': True,
            'type': 'models.PUERental',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)



# we have to import ourselves as relation types are namespaced to models
# e.g. models.Post
from . import models, actions

# required to support relationships between models
model_rebuild(SolarHub)
model_rebuild(User)
model_rebuild(Note)
model_rebuild(BEPPPBattery_Notes)
model_rebuild(Rental_Notes)
model_rebuild(PUE_Notes)
model_rebuild(PUERental_Notes)
model_rebuild(BEPPPBattery)
model_rebuild(LiveData)
model_rebuild(Rental)
model_rebuild(ProductiveUseEquipment)
model_rebuild(PUERental)
model_rebuild(BatteryPUERental)
